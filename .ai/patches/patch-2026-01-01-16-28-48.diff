diff --git a/Settings/AppConfig.cs b/Settings/AppConfig.cs
index 679e0a4..083c1f0 100644
--- a/Settings/AppConfig.cs
+++ b/Settings/AppConfig.cs
@@ -23,6 +23,7 @@ public sealed class MemorySettings { }
 public sealed class GeneralSettings
 {
     public string RepoRoot { get; set; } = "";
+    public bool TweakFirstMode { get; set; } = true;
     public string SandboxHostPath { get; set; } = "";
     public string SandboxContainerPath { get; set; } = "";
     public string InboxHostPath { get; set; } = DefaultInboxPath();
@@ -30,6 +31,8 @@ public sealed class GeneralSettings
     public string ToolsPath { get; set; } = "";                 // tools.json
     public string ToolPromptsPath { get; set; } = "";           // folder: Tools/Prompt (files named by toolId)
     public string BlueprintTemplatesPath { get; set; } = "";    // folder: BlueprintTemplates (prompt library)
+    public string ToolPlanPrompt { get; set; } = DefaultToolPlanPrompt();
+    public string FinalAnswerPrompt { get; set; } = DefaultFinalAnswerPrompt();
     public string AcceptedAttachmentExtensions { get; set; } = ".txt,.md,.json,.png,.jpg,.jpeg,.pdf,.zip";
     public long MaxAttachmentBytes { get; set; } = 50 * 1024 * 1024;
     public long MaxTotalInboxBytes { get; set; } = 500 * 1024 * 1024;
@@ -74,6 +77,12 @@ Rules:
 
         if (string.IsNullOrWhiteSpace(ExecutionTarget))
             ExecutionTarget = OperatingSystem.IsWindows() ? "WindowsHost" : "LinuxContainer";
+
+        if (string.IsNullOrWhiteSpace(ToolPlanPrompt))
+            ToolPlanPrompt = DefaultToolPlanPrompt();
+
+        if (string.IsNullOrWhiteSpace(FinalAnswerPrompt))
+            FinalAnswerPrompt = DefaultFinalAnswerPrompt();
     }
 
     private static string DefaultInboxPath()
@@ -84,10 +93,33 @@ Rules:
 
         return Path.Combine(basePath, "RahBuilder", "inbox");
     }
+
+    private static string DefaultToolPlanPrompt() =>
+        @"You are the Tool Planner. Output ONLY valid JSON for mode ""tool_plan.v1"" with shape:
+{
+  ""mode"": ""tool_plan.v1"",
+  ""tweakFirst"": true,
+  ""steps"": [
+    { ""id"": ""step1"", ""toolId"": ""file.read.text"" or ""vision.describe.image"", ""inputs"": { ""storedName"": ""<storedName>"" }, ""why"": ""<reason>"" }
+  ]
 }
-
-public sealed class ProvidersSettings
-{
+Rules:
+- Allowed tools ONLY: file.read.text, vision.describe.image.
+- Use storedName exactly as provided in attachments.
+- Always set tweakFirst=true.
+- Prefer the smallest steps; NEVER suggest rebuild/rewrite/reinitialize.
+- Use one step per attachment type needed to satisfy the request.";
+
+    private static string DefaultFinalAnswerPrompt() =>
+        @"You are the Final Responder. Use the TOOL_OUTPUTS JSON plus attachments metadata to answer the user's request in prose.
+Rules:
+- Never claim to have run tools beyond TOOL_OUTPUTS.
+- Reference content and captions from TOOL_OUTPUTS explicitly.
+- Be concise and clear.";
+}
+
+public sealed class ProvidersSettings
+{
     public OpenAiSettings OpenAI { get; set; } = new();
     public HuggingFaceSettings HuggingFace { get; set; } = new();
     public OllamaSettings Ollama { get; set; } = new();
diff --git a/Settings/Pages/GeneralSettingsPage.cs b/Settings/Pages/GeneralSettingsPage.cs
index c2faa43..1e3ae43 100644
--- a/Settings/Pages/GeneralSettingsPage.cs
+++ b/Settings/Pages/GeneralSettingsPage.cs
@@ -133,6 +133,7 @@ public sealed class GeneralSettingsPage : UserControl
         AddRow("Sandbox Host Path", () => _config.General.SandboxHostPath, v => _config.General.SandboxHostPath = v);
         AddRow("Sandbox Container Path", () => _config.General.SandboxContainerPath, v => _config.General.SandboxContainerPath = v);
 
+        AddBool("TweakFirst mode (avoid rebuilds)", () => _config.General.TweakFirstMode, v => _config.General.TweakFirstMode = v);
         AddRow("Tools Manifest Path (tools.json)", () => _config.General.ToolsPath, v => _config.General.ToolsPath = v);
         AddRow("Tool Prompts Folder (Tools/Prompt)", () => _config.General.ToolPromptsPath, v => _config.General.ToolPromptsPath = v);
         AddRow("BlueprintTemplates Folder", () => _config.General.BlueprintTemplatesPath, v => _config.General.BlueprintTemplatesPath = v);
@@ -200,14 +201,28 @@ public sealed class GeneralSettingsPage : UserControl
         grid.Controls.Add(execLabel, 0, row);
         grid.Controls.Add(execCombo, 1, row);
         row++;
-
-        AddMultiline(
-            "Global Job Spec Digest Prompt (JSON-only, no tools)",
-            () => _config.General.JobSpecDigestPrompt,
-            v => _config.General.JobSpecDigestPrompt = v,
-            height: 220
-        );
-
-        Controls.Add(grid);
-    }
-}
+
+        AddMultiline(
+            "Global Job Spec Digest Prompt (JSON-only, no tools)",
+            () => _config.General.JobSpecDigestPrompt,
+            v => _config.General.JobSpecDigestPrompt = v,
+            height: 220
+        );
+
+        AddMultiline(
+            "Tool Plan Prompt (tool_plan.v1 only)",
+            () => _config.General.ToolPlanPrompt,
+            v => _config.General.ToolPlanPrompt = v,
+            height: 200
+        );
+
+        AddMultiline(
+            "Final Answer Prompt",
+            () => _config.General.FinalAnswerPrompt,
+            v => _config.General.FinalAnswerPrompt = v,
+            height: 160
+        );
+
+        Controls.Add(grid);
+    }
+}
diff --git a/Workflow/WaitUserGate.cs b/Workflow/WaitUserGate.cs
index e388202..537e824 100644
--- a/Workflow/WaitUserGate.cs
+++ b/Workflow/WaitUserGate.cs
@@ -1,23 +1,57 @@
 #nullable enable
-using System;
-
-namespace RahBuilder.Workflow;
-
-public static class WaitUserGate
-{
-    public static bool IsAllowedResponse(string input)
-    {
-        var s = (input ?? "").Trim().ToLowerInvariant();
-        if (s.Length == 0) return false;
-
-        return s is "yes" or "no" or "accept" or "reject" or "edit";
-    }
-
-    public static string GateMessage(string pendingQuestion)
-    {
-        return
-            "WAIT_USER\n" +
-            $"Pending: {pendingQuestion}\n" +
-            "Allowed replies: yes | no | accept | reject | edit";
-    }
-}
+using System;
+using System.Globalization;
+using System.Text.RegularExpressions;
+
+namespace RahBuilder.Workflow;
+
+public enum WaitUserAction
+{
+    None,
+    Accept,
+    Reject,
+    Edit,
+    AcceptStep
+}
+
+public sealed record WaitUserResponse(WaitUserAction Action, string? EditText = null, int? StepIndex = null);
+
+public static class WaitUserGate
+{
+    private static readonly Regex AcceptStepRx = new(@"^accept\s+step\s+(?<n>\d+)$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+    public static WaitUserResponse ParseResponse(string input)
+    {
+        var s = (input ?? "").Trim();
+        if (s.Length == 0) return new WaitUserResponse(WaitUserAction.None);
+
+        var lower = s.ToLowerInvariant();
+        if (lower == "accept")
+            return new WaitUserResponse(WaitUserAction.Accept);
+        if (lower == "reject")
+            return new WaitUserResponse(WaitUserAction.Reject);
+        if (lower.StartsWith("edit", StringComparison.OrdinalIgnoreCase))
+        {
+            var rest = s.Length > 4 ? s.Substring(4).Trim() : "";
+            return new WaitUserResponse(WaitUserAction.Edit, rest);
+        }
+
+        var m = AcceptStepRx.Match(lower);
+        if (m.Success && int.TryParse(m.Groups["n"].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var idx))
+        {
+            return new WaitUserResponse(WaitUserAction.AcceptStep, StepIndex: idx - 1);
+        }
+
+        return new WaitUserResponse(WaitUserAction.None);
+    }
+
+    public static string GateMessage(string pendingQuestion, string? toolPlanPreview = null)
+    {
+        var preview = string.IsNullOrWhiteSpace(toolPlanPreview) ? "" : $"{toolPlanPreview}\n";
+        return
+            "WAIT_USER\n" +
+            preview +
+            $"Pending: {pendingQuestion}\n" +
+            "Allowed replies: accept | reject | edit <rewrite> | accept step <n>";
+    }
+}
diff --git a/Workflow/WorkflowFacade.cs b/Workflow/WorkflowFacade.cs
index 543af2f..94208db 100644
--- a/Workflow/WorkflowFacade.cs
+++ b/Workflow/WorkflowFacade.cs
@@ -4,26 +4,31 @@ using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text;
+using System.Text.Json;
 using System.Threading;
 using System.Threading.Tasks;
 using RahBuilder.Settings;
 using RahBuilder.Tools.BlueprintTemplates;
 using RahOllamaOnly.Tools;
+using RahOllamaOnly.Tools.Prompt;
 using RahOllamaOnly.Tracing;
-
-namespace RahBuilder.Workflow;
-
-public sealed class WorkflowFacade
-{
-    private readonly RunTrace _trace;
-    private readonly WorkflowRouter _router = new();
+
+namespace RahBuilder.Workflow;
+
+public sealed class WorkflowFacade
+{
+    private readonly RunTrace _trace;
+    private readonly WorkflowRouter _router = new();
     private AppConfig _cfg;
     private IReadOnlyList<AttachmentInbox.AttachmentEntry> _attachments = Array.Empty<AttachmentInbox.AttachmentEntry>();
+    private readonly WorkflowState _state = new();
+    private ToolManifest _toolManifest = new();
+    private ToolPromptRegistry _toolPrompts = new();
 
     private string _lastGraphHash = "";
-
-    // If true, the ONLY allowed reply is: "edit <rewrite>"
-    private bool _forceEditBecauseInvalidJson = false;
+
+    // If true, the ONLY allowed reply is: "edit <rewrite>"
+    private bool _forceEditBecauseInvalidJson = false;
 
     public event Action<string>? UserFacingMessage;
 
@@ -57,31 +62,37 @@ public sealed class WorkflowFacade
     {
         var toolsPath = (_cfg.General.ToolsPath ?? "").Trim();
         var promptDir = (_cfg.General.ToolPromptsPath ?? "").Trim();
-
-        ToolManifest manifest;
-        try
-        {
-            manifest = ToolManifestLoader.LoadFromFile(toolsPath);
-        }
-        catch (Exception ex)
-        {
-            _trace.Emit($"[tooling:error] failed to load tools manifest at '{toolsPath}': {ex.Message}");
-            return;
-        }
-
-        int promptFiles = 0;
-        try
-        {
-            if (!string.IsNullOrWhiteSpace(promptDir) && Directory.Exists(promptDir))
-                promptFiles = Directory.GetFiles(promptDir).Length;
-        }
-        catch { }
-
-        _trace.Emit($"[tooling] tools={manifest.ToolsById.Count} toolPrompts(files)={promptFiles}");
-    }
-
-    public Task RouteUserInput(string text, CancellationToken ct) => RouteUserInput(_cfg, text, ct);
-
+
+        ToolManifest manifest;
+        try
+        {
+            manifest = ToolManifestLoader.LoadFromFile(toolsPath);
+        }
+        catch (Exception ex)
+        {
+            _trace.Emit($"[tooling:error] failed to load tools manifest at '{toolsPath}': {ex.Message}");
+            return;
+        }
+
+        int promptFiles = 0;
+        var prompts = new ToolPromptRegistry();
+        try
+        {
+            if (!string.IsNullOrWhiteSpace(promptDir) && Directory.Exists(promptDir))
+            {
+                prompts.LoadFromDirectory(promptDir);
+                promptFiles = prompts.AllToolIds.Count;
+            }
+        }
+        catch { }
+
+        _toolManifest = manifest;
+        _toolPrompts = prompts;
+        _trace.Emit($"[tooling] tools={manifest.ToolsById.Count} toolPrompts(files)={promptFiles}");
+    }
+
+    public Task RouteUserInput(string text, CancellationToken ct) => RouteUserInput(_cfg, text, ct);
+
     public async Task RouteUserInput(AppConfig cfg, string text, CancellationToken ct)
     {
         if (cfg != null) _cfg = cfg;
@@ -109,10 +120,53 @@ public sealed class WorkflowFacade
             text = edited;
             _trace.Emit($"[chat:edit] {text}");
 
-            // We have new input, try digest again.
+            // We have new input, try digest again.
             _forceEditBecauseInvalidJson = false;
         }
 
+        if (_state.PendingToolPlan != null)
+        {
+            var resp = WaitUserGate.ParseResponse(text);
+            if (resp.Action == WaitUserAction.Edit)
+            {
+                var edited = resp.EditText ?? "";
+                if (string.IsNullOrWhiteSpace(edited))
+                {
+                    EmitToolPlanWait();
+                    return;
+                }
+
+                _trace.Emit("[plan:edit] user provided new text, clearing pending tool plan.");
+                _state.ClearPlan();
+                text = edited;
+            }
+            else if (resp.Action == WaitUserAction.Reject)
+            {
+                _trace.Emit("[plan:reject] user rejected pending tool plan.");
+                _state.ClearPlan();
+                EmitWaitUser("Tool plan rejected. Provide a new request.");
+                return;
+            }
+            else if (resp.Action is WaitUserAction.Accept or WaitUserAction.AcceptStep)
+            {
+                var expected = _state.PendingStepIndex;
+                var requested = resp.StepIndex ?? expected;
+                if (requested != expected)
+                {
+                    EmitWaitUser($"Next step is {expected + 1}. Reply with: accept step {expected + 1}");
+                    return;
+                }
+
+                await ExecuteCurrentStepAsync(ct).ConfigureAwait(true);
+                return;
+            }
+            else
+            {
+                EmitToolPlanWait();
+                return;
+            }
+        }
+
         var repoScope = RepoScope.Resolve(_cfg);
         _trace.Emit(repoScope.Message);
         if (!repoScope.Ok)
@@ -193,12 +247,20 @@ public sealed class WorkflowFacade
         if (!string.IsNullOrWhiteSpace(rawJson))
             _trace.Emit("[jobspec] " + Trunc(rawJson, 800));
 
-        EmitAttachmentSuggestions();
-        _trace.Emit("[planner] not wired: no execution performed.");
+        if (_attachments == null || _attachments.Count == 0)
+        {
+            _trace.Emit("[attachments:none] Add at least one attachment to proceed to tool plan.");
+            EmitWaitUser("Attach at least one file, then reply with: accept (after plan appears).");
+            return;
+        }
+
+        var planOk = await BuildToolPlanAsync(text, rawJson, ct).ConfigureAwait(true);
+        if (planOk)
+            EmitToolPlanWait();
     }
-
+
     private async Task<JobSpec> RunJobSpecDigestAsync(string userText, CancellationToken ct)
-    {
+    {
         var prompt = (_cfg.General.JobSpecDigestPrompt ?? "").Trim();
         if (prompt.Length == 0)
         {
@@ -297,37 +359,6 @@ public sealed class WorkflowFacade
         return sb.ToString();
     }
 
-    private void EmitAttachmentSuggestions()
-    {
-        if (_attachments == null || _attachments.Count == 0)
-        {
-            _trace.Emit("[attachments] none");
-            return;
-        }
-
-        var blueprint = LoadAttachmentBlueprint();
-        if (blueprint == null)
-        {
-            _trace.Emit("[attachments] blueprint attachment.ingest.v1 missing or unreadable.");
-            return;
-        }
-
-        _trace.Emit($"[attachments] {_attachments.Count} attachment(s) present. blueprint={blueprint.TemplatePath} visibility={blueprint.Visibility}");
-
-        foreach (var a in _attachments)
-        {
-            var tools = new List<string>();
-            var kind = (a.Kind ?? "").ToLowerInvariant();
-            if (kind == "image")
-                tools.AddRange(blueprint.ImageTools);
-            else if (kind == "document")
-                tools.AddRange(blueprint.DocumentTools);
-
-            var toolText = tools.Count == 0 ? "none" : string.Join(", ", tools.Distinct(StringComparer.OrdinalIgnoreCase));
-            _trace.Emit($"[attachments:suggest] {a.StoredName} ({kind}, {a.SizeBytes} bytes) -> {toolText}");
-        }
-    }
-
     private AttachmentBlueprintInfo? LoadAttachmentBlueprint()
     {
         var folder = (_cfg.General.BlueprintTemplatesPath ?? "").Trim();
@@ -415,4 +446,217 @@ public sealed class WorkflowFacade
         public List<string> ImageTools { get; init; } = new();
         public List<string> DocumentTools { get; init; } = new();
     }
+
+    private async Task<bool> BuildToolPlanAsync(string userText, string jobSpecJson, CancellationToken ct)
+    {
+        var prompt = (_cfg.General.ToolPlanPrompt ?? "").Trim();
+        if (prompt.Length == 0)
+        {
+            _trace.Emit("[toolplan:error] ToolPlanPrompt is empty (General.ToolPlanPrompt).");
+            EmitWaitUser("ToolPlan prompt is empty. Update Settings -> General -> Tool Plan Prompt.");
+            return false;
+        }
+
+        var blueprint = LoadAttachmentBlueprint();
+        var sb = new StringBuilder();
+        sb.AppendLine("USER REQUEST:");
+        sb.AppendLine(userText ?? "");
+        sb.AppendLine();
+        sb.AppendLine("JOB_SPEC_JSON:");
+        sb.AppendLine(jobSpecJson ?? "");
+        sb.AppendLine();
+        sb.AppendLine("ATTACHMENTS:");
+        foreach (var a in _attachments)
+        {
+            sb.AppendLine($"- storedName: {a.StoredName}, kind: {a.Kind}, sizeBytes: {a.SizeBytes}, sha256: {a.Sha256}");
+        }
+
+        if (blueprint != null)
+        {
+            sb.AppendLine();
+            sb.AppendLine("SUGGESTED_TOOLS:");
+            sb.AppendLine("imageTools: " + string.Join(", ", blueprint.ImageTools));
+            sb.AppendLine("documentTools: " + string.Join(", ", blueprint.DocumentTools));
+        }
+
+        string toolPlanText;
+        try
+        {
+            toolPlanText = await LlmInvoker.InvokeChatAsync(_cfg, "Orchestrator", prompt, sb.ToString(), ct).ConfigureAwait(false);
+        }
+        catch (Exception ex)
+        {
+            _trace.Emit("[toolplan:error] invoke failed: " + ex.Message);
+            EmitWaitUser("ToolPlan invocation failed. Reply with: edit <rewrite your request>");
+            return false;
+        }
+
+        _trace.Emit("[toolplan:raw] " + Trunc(toolPlanText, 1200));
+
+        var plan = ToolPlanParser.TryParse(toolPlanText);
+        if (plan == null)
+        {
+            _forceEditBecauseInvalidJson = true;
+            EmitWaitUser("Model output was not valid JSON. Reply with: edit <rewrite your request>");
+            return false;
+        }
+
+        if (_cfg.General.TweakFirstMode && !plan.TweakFirst)
+        {
+            _trace.Emit("[toolplan:error] tweakFirst required.");
+            EmitWaitUser("Tool plan must set tweakFirst=true. Reply with: edit <rewrite your request>");
+            return false;
+        }
+
+        if (!ValidateToolPlan(plan))
+        {
+            EmitWaitUser("Tool plan invalid. Reply with: edit <rewrite your request>");
+            return false;
+        }
+
+        _state.PendingToolPlanJson = toolPlanText;
+        _state.PendingToolPlan = plan;
+        _state.PendingStepIndex = 0;
+        _state.ToolOutputs = new List<System.Text.Json.JsonElement>();
+        _state.LastJobSpecJson = jobSpecJson;
+        _state.OriginalUserText = userText;
+        return true;
+    }
+
+    private bool ValidateToolPlan(ToolPlan plan)
+    {
+        if (plan == null || plan.Steps == null || plan.Steps.Count == 0)
+            return false;
+
+        foreach (var step in plan.Steps)
+        {
+            if (!_toolManifest.Has(step.ToolId))
+            {
+                _trace.Emit($"[toolplan:error] step tool not in manifest: {step.ToolId}");
+                return false;
+            }
+            if (!_toolPrompts.Has(step.ToolId))
+            {
+                _trace.Emit($"[toolplan:error] step tool missing prompt: {step.ToolId}");
+                return false;
+            }
+
+            if (!step.Inputs.TryGetValue("storedName", out var stored) || string.IsNullOrWhiteSpace(stored))
+            {
+                _trace.Emit("[toolplan:error] step missing storedName input.");
+                return false;
+            }
+
+            var att = _attachments.FirstOrDefault(a => string.Equals(a.StoredName, stored, StringComparison.OrdinalIgnoreCase));
+            if (att == null)
+            {
+                _trace.Emit($"[toolplan:error] attachment not found for storedName: {stored}");
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private void EmitToolPlanWait()
+    {
+        if (_state.PendingToolPlan == null)
+        {
+            EmitWaitUser("No pending tool plan. Reply with: edit <rewrite your request>");
+            return;
+        }
+
+        var sb = new StringBuilder();
+        sb.AppendLine("ToolPlan Steps:");
+        for (int i = 0; i < _state.PendingToolPlan.Steps.Count; i++)
+        {
+            var step = _state.PendingToolPlan.Steps[i];
+            var prefix = i == _state.PendingStepIndex ? "->" : "  ";
+            sb.AppendLine($"{prefix} Step {i + 1}: {step.ToolId} ({step.Id}) inputs: {string.Join(", ", step.Inputs.Select(kv => $"{kv.Key}={kv.Value}"))} why: {step.Why}");
+        }
+
+        var msg = WaitUserGate.GateMessage("Approve tool plan to continue.", sb.ToString().TrimEnd());
+        _state.PendingQuestion = msg;
+        _trace.Emit(msg);
+        UserFacingMessage?.Invoke(msg);
+    }
+
+    private async Task ExecuteCurrentStepAsync(CancellationToken ct)
+    {
+        if (_state.PendingToolPlan == null)
+        {
+            EmitWaitUser("No tool plan to execute.");
+            return;
+        }
+
+        if (_state.PendingStepIndex < 0 || _state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
+        {
+            EmitWaitUser("Tool plan step index invalid.");
+            _state.ClearPlan();
+            return;
+        }
+
+        var step = _state.PendingToolPlan.Steps[_state.PendingStepIndex];
+        var result = await ToolStepRunner.RunAsync(step, _cfg, _trace, _attachments, _toolManifest, _toolPrompts, ct).ConfigureAwait(false);
+        if (!result.Ok)
+        {
+            EmitWaitUser(result.Message);
+            return;
+        }
+
+        if (result.Output.HasValue)
+            _state.ToolOutputs.Add(result.Output.Value);
+
+        _state.PendingStepIndex++;
+        if (_state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
+        {
+            await ProduceFinalResponseAsync(ct).ConfigureAwait(false);
+            _state.ClearPlan();
+            return;
+        }
+
+        EmitToolPlanWait();
+    }
+
+    private async Task ProduceFinalResponseAsync(CancellationToken ct)
+    {
+        var prompt = (_cfg.General.FinalAnswerPrompt ?? "").Trim();
+        if (prompt.Length == 0)
+        {
+            _trace.Emit("[final:error] FinalAnswerPrompt is empty.");
+            EmitWaitUser("FinalAnswerPrompt is empty. Update settings.");
+            return;
+        }
+
+        var sb = new StringBuilder();
+        sb.AppendLine("USER REQUEST:");
+        sb.AppendLine(_state.OriginalUserText ?? "");
+        sb.AppendLine();
+        sb.AppendLine("JOB_SPEC_JSON:");
+        sb.AppendLine(_state.LastJobSpecJson ?? "");
+        sb.AppendLine();
+        sb.AppendLine("ATTACHMENTS:");
+        foreach (var a in _attachments)
+        {
+            sb.AppendLine($"- storedName: {a.StoredName}, kind: {a.Kind}, sizeBytes: {a.SizeBytes}, sha256: {a.Sha256}");
+        }
+        sb.AppendLine();
+        sb.AppendLine("TOOL_OUTPUTS:");
+        sb.AppendLine(JsonSerializer.Serialize(_state.ToolOutputs));
+
+        string resp;
+        try
+        {
+            resp = await LlmInvoker.InvokeChatAsync(_cfg, "Orchestrator", prompt, sb.ToString(), ct).ConfigureAwait(false);
+        }
+        catch (Exception ex)
+        {
+            _trace.Emit("[final:error] " + ex.Message);
+            EmitWaitUser("Final response failed. Reply with: edit <rewrite your request>");
+            return;
+        }
+
+        _trace.Emit("[final] " + Trunc(resp, 1200));
+        UserFacingMessage?.Invoke(resp);
+    }
 }
diff --git a/Workflow/WorkflowState.cs b/Workflow/WorkflowState.cs
index 4e65a13..0afaf84 100644
--- a/Workflow/WorkflowState.cs
+++ b/Workflow/WorkflowState.cs
@@ -1,7 +1,26 @@
-#nullable enable
-namespace RahBuilder.Workflow;
-
-public sealed class WorkflowState
-{
-    public string? PendingQuestion { get; set; }
-}
+#nullable enable
+using System.Collections.Generic;
+using System.Text.Json;
+
+namespace RahBuilder.Workflow;
+
+public sealed class WorkflowState
+{
+    public string? PendingQuestion { get; set; }
+    public string? PendingToolPlanJson { get; set; }
+    public ToolPlan? PendingToolPlan { get; set; }
+    public int PendingStepIndex { get; set; }
+    public List<JsonElement> ToolOutputs { get; set; } = new();
+    public string? LastJobSpecJson { get; set; }
+    public string? OriginalUserText { get; set; }
+
+    public void ClearPlan()
+    {
+        PendingToolPlanJson = null;
+        PendingToolPlan = null;
+        PendingStepIndex = 0;
+        ToolOutputs = new List<JsonElement>();
+        LastJobSpecJson = null;
+        OriginalUserText = null;
+    }
+}
