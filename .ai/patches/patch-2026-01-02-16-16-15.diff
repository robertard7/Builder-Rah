diff --git a/MainForm.cs b/MainForm.cs
index e62b46b..dca8a9b 100644
--- a/MainForm.cs
+++ b/MainForm.cs
@@ -1,10 +1,11 @@
 #nullable enable
-using System;
+using System;
+using System.Collections.Generic;
 using System.Drawing;
 using System.IO;
-using System.Threading;
-using System.Threading.Tasks;
-using System.Windows.Forms;
+using System.Threading;
+using System.Threading.Tasks;
+using System.Windows.Forms;
 using RahBuilder.Settings;
 using RahBuilder.Workflow;
 using RahBuilder.Ui;
@@ -32,6 +33,7 @@ public sealed class MainForm : Form
     private readonly ToolStripStatusLabel _repoStatus;
     private readonly ToolStripStatusLabel _attachmentsStatus;
     private readonly ToolStripStatusLabel _workflowStatus;
+    private readonly List<OutputCard> _cards = new();
     private readonly TableLayoutPanel _stepPanel;
     private readonly Label _planSummaryLabel;
     private readonly Label _stepLabel;
@@ -42,6 +44,8 @@ public sealed class MainForm : Form
     private readonly Panel _clarifyPanel;
     private readonly Label _clarifyLabel;
     private readonly SplitContainer _chatSplit;
+    private readonly ListBox _cardList;
+    private readonly RichTextBox _cardDetail;
 
     public MainForm()
     {
@@ -56,10 +60,11 @@ public sealed class MainForm : Form
         _inbox = new AttachmentInbox(_config.General, _trace);
 
         _workflow = new WorkflowFacade(_trace);
-        _workflow.UserFacingMessage += s => AppendChat(s + "\n");
+        _workflow.UserFacingMessage += OnUserFacingMessage;
         _workflow.StatusChanged += UpdateStatus;
         _workflow.PendingQuestionChanged += UpdateClarify;
         _workflow.PendingStepChanged += UpdateStepPanel;
+        _workflow.OutputCardProduced += OnOutputCardProduced;
         _workflow.TraceAttentionRequested += ShowTracePane;
 
         var tabs = new TabControl { Dock = DockStyle.Fill };
@@ -185,31 +190,62 @@ public sealed class MainForm : Form
         _clarifyPanel.BringToFront();
         topButtons.BringToFront();
 
-        // Right side: trace
+        // Right side: trace + output cards
         _traceBox = new TextBox
         {
             Dock = DockStyle.Fill,
-            Multiline = true,
-            ScrollBars = ScrollBars.Both,
-            ReadOnly = true,
-            WordWrap = false,
-            Font = new Font("Consolas", 9f)
-        };
-
-        _traceWriter.Updated += () =>
-        {
-            if (!IsHandleCreated) return;
-
-            BeginInvoke(new Action(() =>
-            {
-                _traceBox.Text = _traceWriter.Snapshot();
+            Multiline = true,
+            ScrollBars = ScrollBars.Both,
+            ReadOnly = true,
+            WordWrap = false,
+            Font = new Font("Consolas", 9f)
+        };
+
+        _cardList = new ListBox
+        {
+            Dock = DockStyle.Left,
+            Width = 260,
+            HorizontalScrollbar = true
+        };
+        _cardList.SelectedIndexChanged += (_, _) => ShowSelectedCard();
+
+        _cardDetail = new RichTextBox
+        {
+            Dock = DockStyle.Fill,
+            Multiline = true,
+            ReadOnly = true,
+            WordWrap = true,
+            Font = new Font("Segoe UI", 9f)
+        };
+
+        var outputSplit = new SplitContainer
+        {
+            Dock = DockStyle.Fill,
+            Orientation = Orientation.Vertical,
+            Panel1MinSize = 200,
+            SplitterDistance = 260
+        };
+        outputSplit.Panel1.Controls.Add(_cardList);
+        outputSplit.Panel2.Controls.Add(_cardDetail);
+
+        var auxTabs = new TabControl { Dock = DockStyle.Fill };
+        auxTabs.TabPages.Add(new TabPage("Trace") { Controls = { _traceBox } });
+        auxTabs.TabPages.Add(new TabPage("Outputs") { Controls = { outputSplit } });
+
+        _traceWriter.Updated += () =>
+        {
+            if (!IsHandleCreated) return;
+
+            BeginInvoke(new Action(() =>
+            {
+                _traceBox.Text = _traceWriter.Snapshot();
                 _traceBox.SelectionStart = _traceBox.TextLength;
                 _traceBox.ScrollToCaret();
             }));
         };
 
         _chatSplit.Panel1.Controls.Add(leftPanel);
-        _chatSplit.Panel2.Controls.Add(_traceBox);
+        _chatSplit.Panel2.Controls.Add(auxTabs);
 
         tabs.TabPages.Add(new TabPage("Chat") { Controls = { _chatSplit } });
 
@@ -244,6 +280,7 @@ public sealed class MainForm : Form
             _workflow.StatusChanged -= UpdateStatus;
             _workflow.PendingQuestionChanged -= UpdateClarify;
             _workflow.PendingStepChanged -= UpdateStepPanel;
+            _workflow.OutputCardProduced -= OnOutputCardProduced;
             _workflow.TraceAttentionRequested -= ShowTracePane;
         };
 
@@ -356,6 +393,29 @@ public sealed class MainForm : Form
         _stepPanel.Visible = hasPlan && !string.IsNullOrWhiteSpace(summary);
     }
 
+    private void OnOutputCardProduced(OutputCard card)
+    {
+        if (InvokeRequired)
+        {
+            BeginInvoke(new Action<OutputCard>(OnOutputCardProduced), card);
+            return;
+        }
+
+        _cards.Add(card);
+        _cardList.Items.Add($"{card.Kind}: {card.Title}");
+        if (_cardList.Items.Count > 0)
+            _cardList.SelectedIndex = _cardList.Items.Count - 1;
+        _cardDetail.Text = card.ToDisplayText();
+    }
+
+    private void ShowSelectedCard()
+    {
+        if (_cardList.SelectedIndex < 0 || _cardList.SelectedIndex >= _cards.Count)
+            return;
+
+        _cardDetail.Text = _cards[_cardList.SelectedIndex].ToDisplayText();
+    }
+
     private void ToggleTracePane()
     {
         _chatSplit.Panel2Collapsed = !_chatSplit.Panel2Collapsed;
@@ -414,8 +474,19 @@ public sealed class MainForm : Form
 
     private void EditPlan()
     {
-        _workflow.RequestPlanEdit();
-        UpdateStepPanel(null, false);
+        var plan = _workflow.GetPendingPlan();
+        if (plan == null)
+        {
+            _workflow.RequestPlanEdit();
+            UpdateStepPanel(null, false);
+            return;
+        }
+
+        using var editor = new PlanEditorForm(plan);
+        if (editor.ShowDialog(this) == DialogResult.OK && editor.Result != null)
+        {
+            _workflow.ApplyEditedPlan(editor.Result);
+        }
     }
 
     private void CreateDemoAttachments()
diff --git a/Settings/AppConfig.cs b/Settings/AppConfig.cs
index 58e25b4..5e42862 100644
--- a/Settings/AppConfig.cs
+++ b/Settings/AppConfig.cs
@@ -33,7 +33,9 @@ public sealed class GeneralSettings
     public string ToolPromptsPath { get; set; } = "";           // folder: Tools/Prompt (files named by toolId)
     public string BlueprintTemplatesPath { get; set; } = "";    // folder: BlueprintTemplates (prompt library)
     public string ToolPlanPrompt { get; set; } = DefaultToolPlanPrompt();
+    public string IntentExtractorPrompt { get; set; } = DefaultIntentExtractorPrompt();
     public string FinalAnswerPrompt { get; set; } = DefaultFinalAnswerPrompt();
+    public string ProgramBuilderPrompt { get; set; } = DefaultProgramBuilderPrompt();
     public string AcceptedAttachmentExtensions { get; set; } = ".txt,.md,.json,.png,.jpg,.jpeg,.pdf,.zip";
     public long MaxAttachmentBytes { get; set; } = 50 * 1024 * 1024;
     public long MaxTotalInboxBytes { get; set; } = 500 * 1024 * 1024;
@@ -42,6 +44,8 @@ public sealed class GeneralSettings
     public bool ContainerOnly { get; set; } = true;
     public bool EnableGlobalClipboardShortcuts { get; set; } = true;
     public string ExecutionTarget { get; set; } = OperatingSystem.IsWindows() ? "WindowsHost" : "LinuxContainer";
+    public bool EnableProviderApi { get; set; } = true;
+    public int ProviderApiPort { get; set; } = 5050;
 
     // SAVE POINT: global digest prompt lives here (JSON-only, no tools)
     public string JobSpecDigestPrompt { get; set; } =
@@ -100,8 +104,17 @@ Rules:
         if (string.IsNullOrWhiteSpace(FinalAnswerPrompt))
             FinalAnswerPrompt = DefaultFinalAnswerPrompt();
 
+        if (string.IsNullOrWhiteSpace(IntentExtractorPrompt))
+            IntentExtractorPrompt = DefaultIntentExtractorPrompt();
+
+        if (string.IsNullOrWhiteSpace(ProgramBuilderPrompt))
+            ProgramBuilderPrompt = DefaultProgramBuilderPrompt();
+
         if (!Enum.IsDefined(typeof(ConversationMode), ConversationMode))
             ConversationMode = ConversationMode.Conversational;
+
+        if (ProviderApiPort <= 0)
+            ProviderApiPort = 5050;
     }
 
     private static string DefaultInboxPath()
@@ -130,12 +143,46 @@ Rules:
 - Use one step per attachment type needed to satisfy the request.
 - Do NOT output prose or markdown; ONLY JSON.";
 
+    private static string DefaultIntentExtractorPrompt() =>
+        @"You are the Intent Extractor. Produce ONE JSON object only (no prose).
+Shape:
+{
+  ""mode"": ""intent.v1"",
+  ""request"": ""<verbatim user text>"",
+  ""goal"": ""<plain goal>"",
+  ""context"": ""<important background>"",
+  ""actions"": [""action 1"", ""action 2""],
+  ""constraints"": [""constraint"", ""examples""],
+  ""clarification"": ""<one short question if needed else empty>"",
+  ""missing"": [""goal|actions|constraints|context|attachments""],
+  ""ready"": true|false
+}
+Rules:
+- Detect multi-step requests signaled by words like 'then', 'after', 'also', 'next'; split them into separate entries in actions.
+- Reflect attachments and history if provided.
+- Ask at most ONE clarification for a missing concept.
+- ready=true only when goal + actions are clear.";
+
     private static string DefaultFinalAnswerPrompt() =>
         @"You are the Final Responder. Use the TOOL_OUTPUTS JSON plus attachments metadata to answer the user's request in natural, concise language.
 Rules:
 - Do not mention internal systems or planner details.
 - Reference content and captions from TOOL_OUTPUTS explicitly.
 - Keep it brief and helpful.";
+
+    private static string DefaultProgramBuilderPrompt() =>
+        @"You are the Program Builder. Output JSON ONLY with shape:
+{
+  ""mode"": ""program_artifacts.v1"",
+  ""files"": [
+    { ""path"": ""README.md"", ""content"": ""..."", ""tags"": [""readme""] },
+    { ""path"": ""Tests/sample.test"", ""content"": ""..."", ""tags"": [""test""] }
+  ]
+}
+Rules:
+- Include README, at least one test file, and main source files.
+- Respect constraints like ""short summary"" or ""include code examples"".
+- Do not emit markdown fences; JSON only.";
 }
 
 public enum ConversationMode
diff --git a/Workflow/WorkflowFacade.cs b/Workflow/WorkflowFacade.cs
index cb48c78..4964cbb 100644
--- a/Workflow/WorkflowFacade.cs
+++ b/Workflow/WorkflowFacade.cs
@@ -19,6 +19,9 @@ public sealed class WorkflowFacade
 {
     private readonly RunTrace _trace;
     private readonly WorkflowRouter _router = new();
+    private readonly ExecutionOrchestrator _executor;
+    private readonly ProgramArtifactGenerator _artifactGenerator = new();
+    private readonly ProviderApiHost _apiHost;
     private AppConfig _cfg;
     private IReadOnlyList<AttachmentInbox.AttachmentEntry> _attachments = Array.Empty<AttachmentInbox.AttachmentEntry>();
     private readonly WorkflowState _state = new();
@@ -30,6 +33,7 @@ public sealed class WorkflowFacade
 
     // If true, the ONLY allowed reply is: "edit <rewrite>"
     private bool _forceEditBecauseInvalidJson = false;
+    private bool _planNeedsArtifacts;
 
     public sealed record RunnerBuildSummary(
         bool Ok,
@@ -61,21 +65,53 @@ public sealed class WorkflowFacade
     public event Action<string?>? PendingQuestionChanged;
     public event Action<string?, bool>? PendingStepChanged;
     public event Action? TraceAttentionRequested;
+    public event Action<OutputCard>? OutputCardProduced;
 
     public WorkflowFacade(RunTrace trace)
     {
         _trace = trace ?? throw new ArgumentNullException(nameof(trace));
         _cfg = ConfigStore.Load();
+        _executor = new ExecutionOrchestrator(_state, _trace);
+        _executor.OutputCardProduced += card => OutputCardProduced?.Invoke(card);
+        _executor.UserFacingMessage += msg =>
+        {
+            RecordAssistantMessage(msg);
+            UserFacingMessage?.Invoke(msg);
+        };
+        _apiHost = new ProviderApiHost(this);
         SyncGraphToHub(_cfg);
         LogRepoBanner();
+        StartApiHostIfEnabled();
     }
 
     public WorkflowFacade(AppConfig cfg, RunTrace trace)
     {
         _cfg = cfg ?? throw new ArgumentNullException(nameof(cfg));
         _trace = trace ?? throw new ArgumentNullException(nameof(trace));
+        _executor = new ExecutionOrchestrator(_state, _trace);
+        _executor.OutputCardProduced += card => OutputCardProduced?.Invoke(card);
+        _executor.UserFacingMessage += msg =>
+        {
+            RecordAssistantMessage(msg);
+            UserFacingMessage?.Invoke(msg);
+        };
+        _apiHost = new ProviderApiHost(this);
         SyncGraphToHub(_cfg);
         LogRepoBanner();
+        StartApiHostIfEnabled();
+    }
+
+    private void StartApiHostIfEnabled()
+    {
+        try
+        {
+            if (_cfg.General.EnableProviderApi)
+                _apiHost.Start(_cfg.General.ProviderApiPort);
+        }
+        catch (Exception ex)
+        {
+            _trace.Emit("[api:warn] " + ex.Message);
+        }
     }
 
     public void RefreshTooling(AppConfig cfg)
@@ -100,6 +136,7 @@ public sealed class WorkflowFacade
         _state.ClearClarifications();
         PendingStepChanged?.Invoke("", false);
         NotifyStatus();
+        _planNeedsArtifacts = false;
     }
 
     public void RequestPlanEdit()
@@ -119,6 +156,38 @@ public sealed class WorkflowFacade
         NotifyStatus();
     }
 
+    public ToolPlan? GetPendingPlan() => _state.PendingToolPlan;
+
+    public void ApplyEditedPlan(ToolPlan? plan)
+    {
+        if (plan == null)
+        {
+            EmitWaitUser("Plan edit cancelled.");
+            return;
+        }
+
+        if (!ValidateToolPlan(plan))
+        {
+            EmitWaitUser("Edited plan is invalid. Please adjust and try again.");
+            return;
+        }
+
+        var planJson = JsonSerializer.Serialize(new
+        {
+            mode = "tool_plan.v1",
+            tweakFirst = plan.TweakFirst,
+            steps = plan.Steps.Select(s => new { s.Id, s.ToolId, inputs = s.Inputs, s.Why })
+        });
+
+        _planNeedsArtifacts = ShouldGenerateArtifacts(_state.LastIntent);
+        _state.GenerateArtifacts = _planNeedsArtifacts;
+        _executor.ResetPlan(plan, planJson, _state.LastJobSpecJson ?? "", _state.PendingUserRequest);
+        _state.PendingQuestion = null;
+        _state.PendingStepIndex = 0;
+        PendingStepChanged?.Invoke("", true);
+        EmitToolPlanWait();
+    }
+
     public void RefreshTooling()
     {
         var toolsPath = (_cfg.General.ToolsPath ?? "").Trim();
@@ -160,6 +229,7 @@ public sealed class WorkflowFacade
         text ??= "";
 
         _trace.Emit($"[chat] {text}");
+        _state.Memory.Add("user", text);
         _recentlyCompleted = false;
 
         var action = UserReplyInterpreter.Interpret(_cfg, _state, text);
@@ -253,6 +323,8 @@ public sealed class WorkflowFacade
 
         SyncGraphToHub(_cfg);
 
+        await RunIntentExtractionAsync(text, ct).ConfigureAwait(true);
+
         // No silent fallbacks.
         if (!_cfg.General.GraphDriven)
         {
@@ -290,6 +362,7 @@ public sealed class WorkflowFacade
         if (!spec.IsComplete)
         {
             var missing = spec.GetMissingFields();
+            missing = missing.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
 
             // Special invalid_json case.
             if (missing.Count == 1 && string.Equals(missing[0], "invalid_json", StringComparison.OrdinalIgnoreCase))
@@ -303,10 +376,7 @@ public sealed class WorkflowFacade
             // Normal WAIT_USER (missing real fields)
             _forceEditBecauseInvalidJson = false;
 
-            var unanswered = missing.Where(m => !_state.AskedMissingFields.Contains(m)).ToList();
-            foreach (var m in unanswered)
-                _state.AskedMissingFields.Add(m);
-
+            var unanswered = missing.Where(m => !_state.ClarificationAsked.ContainsKey(m)).ToList();
             if (unanswered.Count == 0)
             {
                 var reminder = _state.PendingQuestion;
@@ -319,26 +389,19 @@ public sealed class WorkflowFacade
                 return;
             }
 
-            var targets = unanswered.Count > 0 ? unanswered : missing;
+            var nextConcept = unanswered[0];
             var question = spec.Clarification;
-            if (string.IsNullOrWhiteSpace(question) && unanswered.Count > 0)
+            if (string.IsNullOrWhiteSpace(question) || !_state.AskedMissingFields.Add(nextConcept))
             {
-                var qs = ClarificationQuestionBank.PickQuestions(targets, 1);
-                _state.PendingQuestions = qs;
+                var qs = ClarificationQuestionBank.PickQuestions(new List<string> { nextConcept }, 1);
                 question = qs.FirstOrDefault();
             }
-            else
-            {
-                var qs = ClarificationQuestionBank.PickQuestions(missing, 1);
-                _state.PendingQuestions = string.IsNullOrWhiteSpace(question) ? qs : new List<string> { question };
-                if (string.IsNullOrWhiteSpace(question))
-                    question = qs.FirstOrDefault();
-            }
 
             if (string.IsNullOrWhiteSpace(question))
                 question = "Could you share a bit more detail so I can finish the plan?";
 
             _state.PendingQuestions = new List<string> { question };
+            _state.ClarificationAsked[nextConcept] = question;
 
             _state.PendingQuestion = question;
             PendingQuestionChanged?.Invoke(_state.PendingQuestion);
@@ -366,6 +429,9 @@ public sealed class WorkflowFacade
         var activeAttachments = GetActiveAttachments();
         if (activeAttachments.Count == 0)
         {
+            if (_planNeedsArtifacts && await HandleProgramOnlyFlowAsync(text, rawJson, ct).ConfigureAwait(true))
+                return;
+
             _trace.Emit("[attachments:none] Add at least one attachment to proceed to tool plan.");
             EmitWaitUser("Attach at least one file or image so I can help.");
             NotifyStatus("Waiting attachments");
@@ -468,6 +534,23 @@ public sealed class WorkflowFacade
         return new RunnerBuildSummary(ok, run.Id, run.Status, run.Conclusion, run.HtmlUrl, logs, errorMsg);
     }
 
+    public IReadOnlyList<OutputCard> GetOutputCards()
+    {
+        return _state.OutputCards.Select(c => OutputCard.Truncate(c)).ToList();
+    }
+
+    public object GetPublicSnapshot()
+    {
+        return new
+        {
+            status = ComputeWorkflowPhase(),
+            stepIndex = _state.PendingStepIndex,
+            steps = _state.PendingToolPlan?.Steps?.Count ?? 0,
+            pendingQuestion = _state.PendingQuestion,
+            ready = _state.PendingToolPlan != null && _state.PendingStepIndex < (_state.PendingToolPlan?.Steps?.Count ?? 0)
+        };
+    }
+
     private async Task<JobSpec> RunJobSpecDigestAsync(string userText, CancellationToken ct)
     {
         var prompt = (_cfg.General.JobSpecDigestPrompt ?? "").Trim();
@@ -513,16 +596,48 @@ public sealed class WorkflowFacade
         {
             _trace.Emit("[digest:error] Digest invocation failed: " + ex.Message);
             return JobSpec.Invalid("digest_invoke_failed");
-        }
-    }
-
+        }
+    }
+
+    private async Task<IntentExtraction?> RunIntentExtractionAsync(string userText, CancellationToken ct)
+    {
+        try
+        {
+            var result = await IntentExtractor.ExtractAsync(_cfg, userText, GetActiveAttachments(), _state.Memory, ct).ConfigureAwait(false);
+            if (!result.Ok || result.Extraction == null)
+            {
+                _trace.Emit("[intent:error] " + result.Error);
+                return null;
+            }
+
+            _trace.Emit("[intent:raw] " + Trunc(result.Raw, 800));
+            _state.LastIntent = result.Extraction;
+            _planNeedsArtifacts = ShouldGenerateArtifacts(result.Extraction);
+            return result.Extraction;
+        }
+        catch (Exception ex)
+        {
+            _trace.Emit("[intent:error] " + ex.Message);
+            return null;
+        }
+    }
+
+    private void RecordAssistantMessage(string? text)
+    {
+        if (string.IsNullOrWhiteSpace(text)) return;
+        _state.Memory.Add("assistant", text);
+    }
+
     private void EmitWaitUser(string reason, string? friendly = null, string? preview = null)
     {
         var msg = WaitUserGate.GateMessage(reason, preview, _cfg.General.ConversationMode);
         _trace.Emit(msg);
         var chat = friendly ?? reason;
         if (!string.IsNullOrWhiteSpace(chat))
+        {
+            RecordAssistantMessage(chat);
             UserFacingMessage?.Invoke(chat);
+        }
     }
 
     private void SyncGraphToHub(AppConfig cfg)
@@ -933,6 +1048,13 @@ public sealed class WorkflowFacade
             sb.AppendLine($"- storedName: {a.StoredName}, kind: {kind}, sizeBytes: {a.SizeBytes}, sha256: {a.Sha256}, suggestedTool: {toolText}");
         }
 
+        var constraints = _state.LastIntent?.Constraints ?? new List<string>();
+        if (constraints.Count > 0)
+        {
+            sb.AppendLine();
+            sb.AppendLine("CONSTRAINTS:" + string.Join(" | ", constraints));
+        }
+
         if (blueprint != null)
         {
             sb.AppendLine();
@@ -997,6 +1119,7 @@ public sealed class WorkflowFacade
         _state.ToolOutputs = new List<System.Text.Json.JsonElement>();
         _state.LastJobSpecJson = jobSpecJson;
         _state.OriginalUserText = userText;
+        _state.GenerateArtifacts = _planNeedsArtifacts;
         _state.PendingQuestion = null;
         NotifyStatus("Planning");
         return true;
@@ -1116,42 +1239,48 @@ public sealed class WorkflowFacade
             return;
         }
 
-        if (_state.PendingStepIndex < 0 || _state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
+        _state.PlanPaused = false;
+        while (true)
         {
-            EmitWaitUser("Tool plan step index invalid.");
-            _state.ClearPlan();
-            NotifyStatus();
-            PendingStepChanged?.Invoke("", false);
-            return;
-        }
+            if (_state.PendingStepIndex < 0 || _state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
+            {
+                EmitWaitUser("Tool plan step index invalid.");
+                _state.ClearPlan();
+                NotifyStatus();
+                PendingStepChanged?.Invoke("", false);
+                return;
+            }
 
-        var step = _state.PendingToolPlan.Steps[_state.PendingStepIndex];
-        NotifyStatus("Tool execution");
-        var result = await ToolStepRunner.RunAsync(step, _cfg, _trace, _attachments, _toolManifest, _toolPrompts, ct).ConfigureAwait(false);
-        if (!result.Ok)
-        {
-            EmitWaitUser(result.Message, "Something went wrong. Want me to retry this step?");
+            var step = _state.PendingToolPlan.Steps[_state.PendingStepIndex];
             NotifyStatus("Tool execution");
-            TraceAttentionRequested?.Invoke();
-            return;
-        }
+            var result = await _executor.RunNextAsync(_cfg, _attachments, _toolManifest, _toolPrompts, ct).ConfigureAwait(false);
+            if (!result.Ok)
+            {
+                EmitWaitUser(result.Message, "Something went wrong. Want me to retry this step?");
+                NotifyStatus("Tool execution");
+                TraceAttentionRequested?.Invoke();
+                return;
+            }
 
-        if (result.Output.HasValue)
-            _state.ToolOutputs.Add(result.Output.Value);
-        SendChatStepSummary(result);
+            SendChatStepSummary(result);
 
-        _state.PendingStepIndex++;
-        if (_state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
-        {
-            await ProduceFinalResponseAsync(ct).ConfigureAwait(false);
-            _state.ClearPlan();
-            NotifyStatus();
-            PendingStepChanged?.Invoke("", false);
-            return;
-        }
+            if (_state.PendingToolPlan == null || _state.PendingStepIndex >= _state.PendingToolPlan.Steps.Count)
+            {
+                await ProduceFinalResponseAsync(ct).ConfigureAwait(false);
+                _state.ClearPlan();
+                _planNeedsArtifacts = false;
+                NotifyStatus();
+                PendingStepChanged?.Invoke("", false);
+                return;
+            }
 
-        NotifyStatus();
-        EmitToolPlanWait();
+            if (!(approveAll || _state.AutoApproveAll))
+            {
+                NotifyStatus();
+                EmitToolPlanWait();
+                return;
+            }
+        }
     }
 
     private async Task ProduceFinalResponseAsync(CancellationToken ct)
@@ -1193,8 +1322,23 @@ public sealed class WorkflowFacade
             return;
         }
 
+        await MaybeGenerateArtifactsAsync(ct).ConfigureAwait(false);
+
+        resp = EnsureNarrative(resp);
         _trace.Emit("[final] " + Trunc(resp, 1200));
+        RecordAssistantMessage(resp);
         UserFacingMessage?.Invoke(resp);
+        var finalCard = new OutputCard
+        {
+            Kind = OutputCardKind.Final,
+            Title = "Final answer",
+            Summary = Trunc(resp, 200),
+            Preview = Trunc(resp, 600),
+            FullContent = resp,
+            Tags = new[] { "final" }
+        };
+        _state.OutputCards.Add(finalCard);
+        OutputCardProduced?.Invoke(finalCard);
         _recentlyCompleted = true;
         _state.PendingUserRequest = "";
         _state.ClearClarifications();
@@ -1211,24 +1355,145 @@ public sealed class WorkflowFacade
         return "Tweak";
     }
 
+    private static bool ShouldGenerateArtifacts(IntentExtraction? intent)
+    {
+        if (intent == null) return false;
+        var goal = (intent.Goal ?? "").ToLowerInvariant();
+        if (goal.Contains("build") || goal.Contains("app") || goal.Contains("program"))
+            return true;
+
+        foreach (var action in intent.Actions ?? Array.Empty<string>())
+        {
+            var a = (action ?? "").ToLowerInvariant();
+            if (a.Contains("build") || a.Contains("create") || a.Contains("generate"))
+                return true;
+        }
+
+        return false;
+    }
+
+    private async Task MaybeGenerateArtifactsAsync(CancellationToken ct)
+    {
+        if (!_state.GenerateArtifacts) return;
+        _state.GenerateArtifacts = false;
+
+        var intent = _state.LastIntent ?? new IntentExtraction("program_artifacts.v1", _state.PendingUserRequest, _state.PendingUserRequest, "", new List<string>(), new List<string>(), "", new List<string>(), true);
+        var repo = RepoScope.Resolve(_cfg);
+        if (!repo.Ok)
+        {
+            _trace.Emit("[program:skip] repo invalid for artifact generation.");
+            return;
+        }
+
+        var result = await _artifactGenerator.GenerateAsync(_cfg, intent, GetActiveAttachments(), repo.RepoRoot, ct).ConfigureAwait(false);
+        if (!result.Ok)
+        {
+            _trace.Emit("[program:error] " + result.Message);
+            return;
+        }
+
+        var previewLines = result.Files.Take(5).Select(f => $"- {f.Path}");
+        var card = new OutputCard
+        {
+            Kind = OutputCardKind.Program,
+            Title = "Program artifacts",
+            Summary = $"Generated {result.Files.Count} files",
+            Preview = string.Join("\n", previewLines),
+            FullContent = $"Folder: {result.Folder}\nZip: {result.ZipPath}",
+            Tags = new[] { "program", "artifact" }
+        };
+
+        _state.OutputCards.Add(card);
+        OutputCardProduced?.Invoke(card);
+        var msg = card.ToDisplayText();
+        RecordAssistantMessage(msg);
+        UserFacingMessage?.Invoke(msg);
+    }
+
+    private async Task<bool> HandleProgramOnlyFlowAsync(string userText, string jobSpecJson, CancellationToken ct)
+    {
+        if (!_planNeedsArtifacts)
+            return false;
+
+        _trace.Emit("[program] No attachments required; generating program artifacts.");
+        _state.LastJobSpecJson = jobSpecJson;
+        _state.OriginalUserText = userText;
+        _state.ToolOutputs = new List<JsonElement>();
+        _state.GenerateArtifacts = true;
+        await MaybeGenerateArtifactsAsync(ct).ConfigureAwait(false);
+        await ProduceFinalResponseAsync(ct).ConfigureAwait(false);
+        _state.ClearPlan();
+        _planNeedsArtifacts = false;
+        PendingStepChanged?.Invoke("", false);
+        NotifyStatus("Done");
+        return true;
+    }
+
+    private static string EnsureNarrative(string resp)
+    {
+        var text = (resp ?? "").Trim();
+        if (text.StartsWith("```"))
+        {
+            var trimmed = text.Trim('`', '\n', '\r');
+            text = trimmed;
+        }
+
+        if (text.StartsWith("{", StringComparison.Ordinal) && text.EndsWith("}", StringComparison.Ordinal))
+        {
+            try
+            {
+                using var doc = JsonDocument.Parse(text);
+                var sb = new System.Text.StringBuilder();
+                foreach (var prop in doc.RootElement.EnumerateObject())
+                    sb.AppendLine($"- {prop.Name}: {prop.Value.GetRawText()}");
+                text = sb.ToString().TrimEnd();
+            }
+            catch
+            {
+                // keep raw text
+            }
+        }
+
+        return text;
+    }
+
     private JobSpec ValidateJobSpec(JobSpec spec)
     {
         if (spec == null) return JobSpec.Invalid("invalid_spec");
 
+        var intent = _state.LastIntent;
         var missing = spec.GetMissingFields();
-        var request = (spec.Request ?? "").Trim();
-        var goal = (spec.Goal ?? "").Trim();
-        var context = spec.Context ?? "";
+        var request = (spec.Request ?? intent?.Request ?? "").Trim();
+        var goal = (spec.Goal ?? intent?.Goal ?? "").Trim();
+        var context = string.IsNullOrWhiteSpace(spec.Context) ? intent?.Context ?? "" : spec.Context;
         var actions = spec.Actions?.Where(a => !string.IsNullOrWhiteSpace(a)).Select(a => a.Trim()).ToList() ?? new List<string>();
+        if (actions.Count == 0 && intent?.Actions != null)
+            actions = intent.Actions.Where(a => !string.IsNullOrWhiteSpace(a)).Select(a => a.Trim()).ToList();
         var constraints = spec.Constraints?.Where(c => !string.IsNullOrWhiteSpace(c)).Select(c => c.Trim()).ToList() ?? new List<string>();
+        if (constraints.Count == 0 && intent?.Constraints != null)
+            constraints = intent.Constraints.Where(c => !string.IsNullOrWhiteSpace(c)).Select(c => c.Trim()).ToList();
         var attachments = spec.Attachments?.Where(a => a != null && !string.IsNullOrWhiteSpace(a.StoredName)).ToList() ?? new List<JobSpecAttachment>();
 
         if (string.IsNullOrWhiteSpace(request))
             AddMissing("request", missing);
+        else
+            _state.ConfirmedFields.Add("request");
+
         if (string.IsNullOrWhiteSpace(goal))
             AddMissing("goal", missing);
+        else
+            _state.ConfirmedFields.Add("goal");
+
         if (actions.Count == 0)
             AddMissing("actions", missing);
+        else
+            _state.ConfirmedFields.Add("actions");
+
+        if (constraints.Count == 0)
+            AddMissing("constraints", missing);
+        else
+            _state.ConfirmedFields.Add("constraints");
+
         if (attachments.Count == 0)
             AddMissing("attachments", missing);
 
@@ -1330,7 +1595,9 @@ public sealed class WorkflowFacade
                 card.AppendLine("├─ Full content");
                 card.AppendLine(IndentMultiline(full, "│ "));
                 card.AppendLine("└ Use Run Next to continue or Edit Plan to adjust the plan.");
-                UserFacingMessage?.Invoke(card.ToString().TrimEnd());
+                var msg = card.ToString().TrimEnd();
+                RecordAssistantMessage(msg);
+                UserFacingMessage?.Invoke(msg);
             }
             else if (toolId.Equals("vision.describe.image", StringComparison.OrdinalIgnoreCase))
             {
@@ -1347,7 +1614,9 @@ public sealed class WorkflowFacade
                 if (!string.IsNullOrWhiteSpace(tags))
                     card.AppendLine("│ Tags: " + tags);
                 card.AppendLine("└ Use Run Next to continue or Edit Plan to adjust the plan.");
-                UserFacingMessage?.Invoke(card.ToString().TrimEnd());
+                var msg = card.ToString().TrimEnd();
+                RecordAssistantMessage(msg);
+                UserFacingMessage?.Invoke(msg);
             }
         }
         catch { }
diff --git a/Workflow/WorkflowState.cs b/Workflow/WorkflowState.cs
index 01c3596..d2a0dfb 100644
--- a/Workflow/WorkflowState.cs
+++ b/Workflow/WorkflowState.cs
@@ -12,13 +12,20 @@ public sealed class WorkflowState
     public ToolPlan? PendingToolPlan { get; set; }
     public int PendingStepIndex { get; set; }
     public List<JsonElement> ToolOutputs { get; set; } = new();
+    public List<OutputCard> OutputCards { get; set; } = new();
     public string? LastJobSpecJson { get; set; }
     public string? OriginalUserText { get; set; }
     public string PendingUserRequest { get; set; } = "";
     public List<string> ClarificationAnswers { get; set; } = new();
     public List<string> PendingQuestions { get; set; } = new();
     public bool AutoApproveAll { get; set; }
+    public bool PlanPaused { get; set; }
+    public IntentExtraction? LastIntent { get; set; }
+    public ChatMemory Memory { get; } = new();
+    public HashSet<string> ConfirmedFields { get; set; } = new(StringComparer.OrdinalIgnoreCase);
+    public Dictionary<string, string> ClarificationAsked { get; set; } = new(StringComparer.OrdinalIgnoreCase);
     public HashSet<string> AskedMissingFields { get; set; } = new(StringComparer.OrdinalIgnoreCase);
+    public bool GenerateArtifacts { get; set; }
 
     public void ClearPlan()
     {
@@ -26,9 +33,12 @@ public sealed class WorkflowState
         PendingToolPlan = null;
         PendingStepIndex = 0;
         ToolOutputs = new List<JsonElement>();
+        OutputCards = new List<OutputCard>();
         LastJobSpecJson = null;
         OriginalUserText = null;
         AutoApproveAll = false;
+        PlanPaused = false;
+        GenerateArtifacts = false;
     }
 
     public void ClearClarifications()
@@ -36,5 +46,7 @@ public sealed class WorkflowState
         ClarificationAnswers = new List<string>();
         PendingQuestions = new List<string>();
         AskedMissingFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        ClarificationAsked = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+        ConfirmedFields = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
     }
 }
