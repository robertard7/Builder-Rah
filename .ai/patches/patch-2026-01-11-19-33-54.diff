diff --git a/Headless/Api/ResilienceApiClient.cs b/Headless/Api/ResilienceApiClient.cs
new file mode 100644
index 0000000..8bc3ddb
--- /dev/null
+++ b/Headless/Api/ResilienceApiClient.cs
@@ -0,0 +1,83 @@
+#nullable enable
+using System;
+using System.Net.Http;
+using System.Net.Http.Json;
+using System.Threading;
+using System.Threading.Tasks;
+
+namespace RahBuilder.Headless.Api;
+
+public sealed class ResilienceApiClient
+{
+    private readonly HttpClient _http;
+
+    public ResilienceApiClient(HttpClient http)
+    {
+        _http = http ?? throw new ArgumentNullException(nameof(http));
+    }
+
+    public async Task<CircuitMetricsSnapshot?> GetMetricsAsync(string? state = null, int? minRetryAttempts = null, CancellationToken ct = default)
+    {
+        var query = QueryBuilder.Create()
+            .Add("state", state)
+            .Add("minRetryAttempts", minRetryAttempts?.ToString());
+        return await _http.GetFromJsonAsync<CircuitMetricsSnapshot>($"/metrics/resilience{query}", ct).ConfigureAwait(false);
+    }
+
+    public async Task<ResilienceMetricsSample[]?> GetHistoryAsync(int minutes = 60, int limit = 300, CancellationToken ct = default)
+    {
+        var query = QueryBuilder.Create()
+            .Add("minutes", minutes.ToString())
+            .Add("limit", limit.ToString());
+        return await _http.GetFromJsonAsync<ResilienceMetricsSample[]>($"/metrics/resilience/history{query}", ct).ConfigureAwait(false);
+    }
+
+    public async Task<ApiOkResponse?> ResetMetricsAsync(CancellationToken ct = default)
+    {
+        using var response = await _http.PutAsync("/metrics/resilience/reset", content: null, ct).ConfigureAwait(false);
+        return await response.Content.ReadFromJsonAsync<ApiOkResponse>(cancellationToken: ct).ConfigureAwait(false);
+    }
+
+    public async Task<ResilienceAlertRule?> CreateAlertRuleAsync(ResilienceAlertRuleRequest request, CancellationToken ct = default)
+    {
+        using var response = await _http.PostAsJsonAsync("/alerts/thresholds", request, ct).ConfigureAwait(false);
+        return await response.Content.ReadFromJsonAsync<ResilienceAlertRule>(cancellationToken: ct).ConfigureAwait(false);
+    }
+
+    public async Task<ResilienceAlertsResponse?> GetAlertsAsync(int limit = 50, CancellationToken ct = default)
+    {
+        var query = QueryBuilder.Create()
+            .Add("limit", limit.ToString());
+        return await _http.GetFromJsonAsync<ResilienceAlertsResponse>($"/alerts{query}", ct).ConfigureAwait(false);
+    }
+
+    public sealed record ApiOkResponse(bool Ok, DateTimeOffset ResetAt);
+
+    public sealed record ResilienceMetricsSample(DateTimeOffset Timestamp, CircuitMetricsSnapshot Metrics);
+
+    public sealed record CircuitMetricsSnapshot(int OpenCount, int HalfOpenCount, int ClosedCount, int RetryAttempts);
+
+    public sealed record ResilienceAlertRuleRequest(string? Name, int OpenThreshold, int RetryThreshold, int WindowMinutes);
+
+    public sealed record ResilienceAlertRule(string Id, string Name, int OpenThreshold, int RetryThreshold, int WindowMinutes, bool Enabled);
+
+    public sealed record ResilienceAlertEvent(string Id, string RuleId, string Message, DateTimeOffset TriggeredAt, int OpenDelta, int RetryDelta);
+
+    public sealed record ResilienceAlertsResponse(ResilienceAlertRule[] Rules, ResilienceAlertEvent[] Events);
+
+    private sealed class QueryBuilder
+    {
+        private readonly System.Collections.Generic.List<string> _parts = new();
+
+        public static QueryBuilder Create() => new();
+
+        public QueryBuilder Add(string key, string? value)
+        {
+            if (!string.IsNullOrWhiteSpace(value))
+                _parts.Add($"{Uri.EscapeDataString(key)}={Uri.EscapeDataString(value)}");
+            return this;
+        }
+
+        public override string ToString() => _parts.Count == 0 ? "" : "?" + string.Join("&", _parts);
+    }
+}
diff --git a/openapi.yaml b/openapi.yaml
index 4dfd5d8..f643403 100644
--- a/openapi.yaml
+++ b/openapi.yaml
@@ -89,6 +89,13 @@ paths:
                     type: string
                   status:
                     $ref: "#/components/schemas/SessionStatus"
+                  resilienceSummary:
+                    type: string
+                    description: Summary of resilience metrics at time of request.
+                  resilience:
+                    $ref: "#/components/schemas/ResilienceMetrics"
+                  resilienceByTool:
+                    $ref: "#/components/schemas/ResilienceMetricsByTool"
                   resilienceSummary:
                     type: string
                   resilience:
@@ -101,6 +108,11 @@ paths:
             application/json:
               schema:
                 $ref: "#/components/schemas/ApiError"
+              examples:
+                notFound:
+                  value:
+                    code: not_found
+                    message: not_found
   /sessions/{id}/plan:
     get:
       summary: Get pending plan
@@ -183,12 +195,25 @@ paths:
             application/json:
               schema:
                 $ref: "#/components/schemas/ApiError"
+              examples:
+                badRequest:
+                  value:
+                    code: bad_request
+                    message: text_required
         "503":
           description: Circuit open
           content:
             application/json:
               schema:
                 $ref: "#/components/schemas/ApiError"
+              examples:
+                circuitOpen:
+                  value:
+                    code: service_unavailable
+                    message: circuit_open
+                    details:
+                      retryAfterSeconds: 30
+                      hint: The circuit breaker is open. Retry after backoff.
   /sessions/{id}/attachments:
     post:
       summary: Add attachment
@@ -251,6 +276,14 @@ paths:
             application/json:
               schema:
                 $ref: "#/components/schemas/ApiError"
+              examples:
+                circuitOpen:
+                  value:
+                    code: service_unavailable
+                    message: circuit_open
+                    details:
+                      retryAfterSeconds: 30
+                      hint: The circuit breaker is open. Retry after backoff.
   /sessions/{id}/cancel:
     post:
       summary: Cancel plan
@@ -290,8 +323,7 @@ paths:
           in: query
           required: false
           schema:
-            type: string
-            enum: [open, halfopen, closed]
+            $ref: "#/components/schemas/ResilienceState"
         - name: minRetryAttempts
           in: query
           required: false
@@ -453,6 +485,9 @@ components:
           type: string
         details:
           type: object
+      example:
+        code: bad_request
+        message: invalid_state
     SessionSummary:
       type: object
       properties:
@@ -463,6 +498,7 @@ components:
           format: date-time
         resilienceSummary:
           type: string
+          description: Summary of resilience metrics at time of request.
         resilience:
           $ref: "#/components/schemas/ResilienceMetrics"
     SessionMessage:
@@ -526,6 +562,17 @@ components:
         retryAttempts:
           type: integer
           description: RetryAttempts (number of retry attempts recorded)
+      example:
+        openCount: 1
+        halfOpenCount: 0
+        closedCount: 5
+        retryAttempts: 3
+    ResilienceState:
+      type: string
+      enum:
+        - open
+        - halfopen
+        - closed
     ResilienceMetricsByTool:
       type: object
       additionalProperties:
@@ -549,6 +596,11 @@ components:
           type: integer
         windowMinutes:
           type: integer
+      example:
+        name: retry-spike
+        openThreshold: 3
+        retryThreshold: 10
+        windowMinutes: 60
     ResilienceAlertRule:
       type: object
       properties:
diff --git a/tools/resilienceClient.ts b/tools/resilienceClient.ts
new file mode 100644
index 0000000..21e0b62
--- /dev/null
+++ b/tools/resilienceClient.ts
@@ -0,0 +1,93 @@
+export type CircuitMetricsSnapshot = {
+  openCount: number;
+  halfOpenCount: number;
+  closedCount: number;
+  retryAttempts: number;
+};
+
+export type ResilienceMetricsSample = {
+  timestamp: string;
+  metrics: CircuitMetricsSnapshot;
+};
+
+export type ResilienceAlertRuleRequest = {
+  name?: string;
+  openThreshold: number;
+  retryThreshold: number;
+  windowMinutes: number;
+};
+
+export type ResilienceAlertRule = ResilienceAlertRuleRequest & {
+  id: string;
+  enabled: boolean;
+};
+
+export type ResilienceAlertEvent = {
+  id: string;
+  ruleId: string;
+  message: string;
+  triggeredAt: string;
+  openDelta: number;
+  retryDelta: number;
+};
+
+export type ResilienceAlertsResponse = {
+  rules: ResilienceAlertRule[];
+  events: ResilienceAlertEvent[];
+};
+
+export type ApiOkResponse = { ok: boolean; resetAt: string };
+
+export class ResilienceClient {
+  constructor(private readonly baseUrl: string, private readonly token?: string) {}
+
+  async getMetrics(params?: { state?: string; minRetryAttempts?: number }): Promise<CircuitMetricsSnapshot> {
+    const query = new URLSearchParams();
+    if (params?.state) query.set("state", params.state);
+    if (params?.minRetryAttempts !== undefined) query.set("minRetryAttempts", String(params.minRetryAttempts));
+    return this.getJson(`/metrics/resilience${query.toString() ? `?${query}` : ""}`);
+  }
+
+  async getHistory(minutes = 60, limit = 300): Promise<ResilienceMetricsSample[]> {
+    const query = new URLSearchParams({ minutes: String(minutes), limit: String(limit) });
+    return this.getJson(`/metrics/resilience/history?${query.toString()}`);
+  }
+
+  async resetMetrics(): Promise<ApiOkResponse> {
+    return this.sendJson<ApiOkResponse>("/metrics/resilience/reset", { method: "PUT" });
+  }
+
+  async createAlertRule(rule: ResilienceAlertRuleRequest): Promise<ResilienceAlertRule> {
+    return this.sendJson<ResilienceAlertRule>("/alerts/thresholds", {
+      method: "POST",
+      body: JSON.stringify(rule)
+    });
+  }
+
+  async getAlerts(limit = 50): Promise<ResilienceAlertsResponse> {
+    const query = new URLSearchParams({ limit: String(limit) });
+    return this.getJson(`/alerts?${query.toString()}`);
+  }
+
+  private async getJson<T>(path: string): Promise<T> {
+    const res = await fetch(this.baseUrl + path, { headers: this.headers() });
+    if (!res.ok) throw new Error(`Request failed: ${res.status}`);
+    return res.json() as Promise<T>;
+  }
+
+  private async sendJson<T>(path: string, init: RequestInit): Promise<T> {
+    const res = await fetch(this.baseUrl + path, {
+      ...init,
+      headers: {
+        ...this.headers(),
+        "Content-Type": "application/json"
+      }
+    });
+    if (!res.ok) throw new Error(`Request failed: ${res.status}`);
+    return res.json() as Promise<T>;
+  }
+
+  private headers(): HeadersInit {
+    return this.token ? { "X-Builder-Token": this.token } : {};
+  }
+}
