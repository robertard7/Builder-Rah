diff --git a/Workflow/JobSpecParser.cs b/Workflow/JobSpecParser.cs
index dcebc5e..e91c0d1 100644
--- a/Workflow/JobSpecParser.cs
+++ b/Workflow/JobSpecParser.cs
@@
     private static List<string> InferActions(string request, List<JobSpecAttachment> attachments)
     {
         var actions = new List<string>();
         var text = (request ?? "").ToLowerInvariant();
         if (string.IsNullOrWhiteSpace(text))
             return actions;
 
         bool hasImage = attachments.Any(a => NormalizeKind(a.Kind) == "image");
         bool hasDoc = attachments.Any(a => NormalizeKind(a.Kind) is "document" or "code");
 
-        var clauses = SplitClauses(text);
-        foreach (var clause in clauses)
-        {
-            if (clause.Contains("describe") && hasImage)
-                actions.Add("describe image");
-            if ((clause.Contains("summarize") || clause.Contains("read") || clause.Contains("analyze")) && hasDoc)
-                actions.Add("summarize document");
-            if (clause.Contains("compare"))
-                actions.Add("compare findings");
-            if (clause.Contains("combine"))
-                actions.Add("combine findings");
-        }
-
-        if (actions.Count == 0)
-        {
-            if (text.Contains("describe") && hasImage)
-                actions.Add("describe image");
-            if ((text.Contains("summarize") || text.Contains("read") || text.Contains("analyze")) && hasDoc)
-                actions.Add("summarize document");
-            if (text.Contains("compare"))
-                actions.Add("compare findings");
-            if (text.Contains("combine") || text.Contains("then") || text.Contains("after"))
-                actions.Add("combine findings");
-        }
-
-        return NormalizeActions(actions);
+        var clauses = SplitClauses(text);
+        foreach (var clause in clauses)
+        {
+            if (clause.Contains("describe") && hasImage)
+                actions.Add("describe image");
+            if ((clause.Contains("summarize") || clause.Contains("read") || clause.Contains("analyze")) && hasDoc)
+                actions.Add("summarize document");
+            if (clause.Contains("compare"))
+                actions.Add("compare findings");
+            if (clause.Contains("combine"))
+                actions.Add("combine findings");
+        }
+
+        if (actions.Count == 0)
+        {
+            if (text.Contains("describe") && hasImage)
+                actions.Add("describe image");
+            if ((text.Contains("summarize") || text.Contains("read") || text.Contains("analyze")) && hasDoc)
+                actions.Add("summarize document");
+            if (text.Contains("compare"))
+                actions.Add("compare findings");
+            if (text.Contains("combine") || text.Contains("then") || text.Contains("after"))
+                actions.Add("combine findings");
+        }
+
+        return NormalizeActions(actions);
     }
@@
     private static List<string> NormalizeActions(IEnumerable<string> actions)
     {
         var list = new List<string>();
         var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
         foreach (var a in actions ?? Enumerable.Empty<string>())
         {
             var val = (a ?? "").Trim();
             if (val.Length == 0 || seen.Contains(val)) continue;
             seen.Add(val);
             list.Add(val);
         }
         return list;
     }
 
     private static List<string> SplitClauses(string text)
     {
         var separators = new[] { " then ", " and then ", " after that ", " after ", " next ", ";", "." };
         var parts = new List<string> { text };
         foreach (var sep in separators)
         {
             parts = parts.SelectMany(p => p.Split(sep, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)).ToList();
         }
         return parts.Where(p => !string.IsNullOrWhiteSpace(p)).ToList();
     }
diff --git a/Workflow/WorkflowFacade.cs b/Workflow/WorkflowFacade.cs
index f6a8b23..a7a6746 100644
--- a/Workflow/WorkflowFacade.cs
+++ b/Workflow/WorkflowFacade.cs
@@
     private string BuildPlanSummary(ToolPlan plan, int currentStepIndex)
     {
         if (plan == null || plan.Steps == null || plan.Steps.Count == 0)
             return "";
 
         var sb = new StringBuilder();
         sb.AppendLine("Plan ready. I will:");
         for (int i = 0; i < plan.Steps.Count; i++)
         {
             var marker = i == currentStepIndex ? "->" : "-";
             sb.AppendLine($"{marker} {StepPhrase(i, plan.Steps[i])}");
         }
         sb.AppendLine("Use Run All to execute, Run Next for one step, Modify Plan to edit, or Stop to cancel.");
         return sb.ToString().TrimEnd();
     }
 
     private static string StepPhrase(int index, ToolPlanStep step)
     {
         var action = DescribeStep(step);
         return $"Step {index + 1}: {action}";
     }
