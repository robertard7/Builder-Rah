{
  "id": "recipe.dotnet.resilience.retry_backoff.v1",
  "kind": "recipe",
  "version": 1,
  "meta": { "visibility": "public", "priority": 50 },
  "title": ".NET Resilience: Retry + Backoff",
  "description": "Adds a lightweight retry helper (no external dependencies).",
  "tags": ["dotnet", "resilience", "retry", "backoff"],
  "updatedUtc": "2025-12-28T00:00:00Z",
  "content": { "steps": [
    { "use": "task.add_file.conflict_policy.v1", "with": { "path": "${projectRoot}/src/Resilience/Retry.cs", "onConflict": "skip", "text": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Resilience;\n\npublic static class Retry\n{\n  public static async Task<T> WithBackoff<T>(Func<Task<T>> op, int attempts = 3, int baseDelayMs = 150, CancellationToken ct = default)\n  {\n    Exception? last = null;\n    for (int i = 0; i < attempts; i++)\n    {\n      ct.ThrowIfCancellationRequested();\n      try { return await op().ConfigureAwait(false); }\n      catch (Exception ex)\n      {\n        last = ex;\n        var delay = baseDelayMs * (int)Math.Pow(2, i);\n        await Task.Delay(delay, ct).ConfigureAwait(false);\n      }\n    }\n    throw last ?? new InvalidOperationException(\"Retry failed\");\n  }\n}\n" } },
    { "use": "task.add_file.conflict_policy.v1", "with": { "path": "${projectRoot}/docs/resilience.md", "onConflict": "skip", "text": "# Resilience\n\nDefault strategy:\n- retries with exponential backoff\n- timeouts\n- idempotency considerations\n\nChoose advanced policies via your environment/settings.\n" } }
  ] }
}
