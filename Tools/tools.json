{
  "version": 3,
  "notes": [
    "OVER-SPEC TOOLBOX: This is a command tool manifest. Each tool is a known id + a shell command template.",
    "All language support is implemented as tools that install dependencies and run builds/tests via apt or direct CLIs.",
    "This file is designed for a Linux toolchain container (apt-get available).",
    "If running on Windows host, prefer adding a separate windows_tools.json that uses PowerShell/winget/cmd semantics.",
    "Args are passed as a raw string and substituted into {args}.",
    "Hard rule: NEVER invent tool ids. Only call ids listed here."
  ],
  "tools": [
    {
      "id": "sys.info",
      "desc": "System info: kernel, CPU, RAM, disk usage, mount points.",
      "cmd": "uname -a && lscpu | head -n 120 && free -h && df -h && mount | head -n 200"
    },
    {
      "id": "sys.env",
      "desc": "Show environment (trimmed).",
      "cmd": "env | sort | head -n 350"
    },
    {
      "id": "sys.ps",
      "desc": "Top processes (CPU/mem).",
      "cmd": "ps aux --sort=-%cpu | head -n 40 && echo '-----' && ps aux --sort=-%mem | head -n 40"
    },
    {
      "id": "sys.uptime",
      "desc": "Uptime + load averages.",
      "cmd": "uptime && cat /proc/loadavg"
    },
    {
      "id": "sys.dmesg",
      "desc": "Kernel messages tail (safe). args: <n optional>",
      "cmd": "n=\"{args}\"; if [ -z \"$n\" ]; then n=220; fi; dmesg --color=never | tail -n \"$n\""
    },
    {
      "id": "sys.mount.check",
      "desc": "Verify /rah/tools and /work mounts exist and are writable.",
      "cmd": "set -e; echo '[check] /rah/tools' && ls -la /rah/tools | head -n 120 && echo '[check] write test' && f=/rah/tools/__mount_test.txt; echo test_$(date +%s) > \"$f\" && cat \"$f\" && rm -f \"$f\" && echo '[check] /work' && ls -la /work | head -n 120"
    },
    {
      "id": "sys.which",
      "desc": "Locate executables. args: <name1> <name2> ...",
      "cmd": "bash -lc \"command -v {args} || true\""
    },
    {
      "id": "sys.os",
      "desc": "Identify OS + distro.",
      "cmd": "uname -srm && (cat /etc/os-release 2>/dev/null || true)"
    },

    {
      "id": "net.ping",
      "desc": "Ping a host. args: <host>",
      "cmd": "h=\"{args}\"; if [ -z \"$h\" ]; then echo 'missing host'; exit 2; fi; ping -c 4 \"$h\""
    },
    {
      "id": "net.dns",
      "desc": "DNS lookup. args: <name>",
      "cmd": "n=\"{args}\"; if [ -z \"$n\" ]; then echo 'missing name'; exit 2; fi; getent hosts \"$n\" || (nslookup \"$n\" 2>/dev/null || true)"
    },
    {
      "id": "net.http.head",
      "desc": "HTTP HEAD request via curl. args: <url>",
      "cmd": "u=\"{args}\"; if [ -z \"$u\" ]; then echo 'missing url'; exit 2; fi; curl -fsS -I \"$u\" | head -n 120"
    },
    {
      "id": "net.http.get",
      "desc": "HTTP GET first N lines. args: <url> [n]",
      "cmd": "set -- {args}; u=\"$1\"; n=\"$2\"; if [ -z \"$u\" ]; then echo 'missing url'; exit 2; fi; if [ -z \"$n\" ]; then n=120; fi; curl -fsS \"$u\" | head -n \"$n\""
    },

    {
      "id": "repo.ls",
      "desc": "List current directory and /work.",
      "cmd": "pwd && ls -la . && echo \"-----\" && ls -la /work"
    },
    {
      "id": "repo.tree",
      "desc": "Tree view (if tree exists) or fallback. args: <path optional>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then p=/work; fi; (command -v tree >/dev/null 2>&1 && tree -L 4 \"$p\") || (find \"$p\" -maxdepth 3 -type d -print | head -n 400)"
    },
    {
      "id": "repo.finddir",
      "desc": "List directories under /work. args: <maxdepth optional>",
      "cmd": "d=\"{args}\"; if [ -z \"$d\" ]; then d=4; fi; case \"$d\" in ''|*[!0-9]*) d=4;; esac; find /work -maxdepth \"$d\" -type d -print | head -n 600"
    },
    {
      "id": "repo.clean",
      "desc": "Danger: remove build artifacts under /work (safe patterns).",
      "cmd": "set -e; cd /work; rm -rf **/bin **/obj **/dist **/build **/.next **/target 2>/dev/null || true; echo '[repo.clean] done'"
    },

    {
      "id": "file.cat",
      "desc": "Print a file (safe). args: <path>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'missing path'; exit 2; fi; if [ ! -f \"$p\" ]; then echo \"not a file: $p\"; exit 2; fi; sed -n '1,340p' \"$p\""
    },
    {
      "id": "file.head",
      "desc": "Show first N lines. args: <path> [n]",
      "cmd": "set -- {args}; p=\"$1\"; n=\"$2\"; if [ -z \"$p\" ]; then echo 'missing path'; exit 2; fi; if [ -z \"$n\" ]; then n=180; fi; head -n \"$n\" \"$p\""
    },
    {
      "id": "file.tail",
      "desc": "Show last N lines. args: <path> [n]",
      "cmd": "set -- {args}; p=\"$1\"; n=\"$2\"; if [ -z \"$p\" ]; then echo 'missing path'; exit 2; fi; if [ -z \"$n\" ]; then n=180; fi; tail -n \"$n\" \"$p\""
    },
    {
      "id": "file.stat",
      "desc": "File info + sha256 (if file). args: <path>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'missing path'; exit 2; fi; if [ ! -e \"$p\" ]; then echo 'not found'; exit 2; fi; ls -la \"$p\" && ( [ -f \"$p\" ] && sha256sum \"$p\" 2>/dev/null || true )"
    },
    {
      "id": "file.find",
      "desc": "Find files by name pattern under /work. args: <pattern>",
      "cmd": "pat=\"{args}\"; if [ -z \"$pat\" ]; then echo 'missing pattern'; exit 2; fi; find /work -type f -iname \"$pat\" | head -n 800"
    },
    {
      "id": "file.searchpath",
      "desc": "Find occurrences of a literal string in one file (safe). args: <path> <pattern>",
      "cmd": "set -- {args}; p=\"$1\"; pat=\"$2\"; if [ -z \"$p\" ] || [ -z \"$pat\" ]; then echo 'usage: <path> <pattern>'; exit 2; fi; if [ ! -f \"$p\" ]; then echo 'not a file'; exit 2; fi; (command -v rg >/dev/null 2>&1 && rg -n --fixed-strings \"$pat\" \"$p\") || (grep -nF \"$pat\" \"$p\" || true)"
    },

    {
      "id": "grep.text",
      "desc": "Search text under /work. args: <pattern>",
      "cmd": "pat=\"{args}\"; if [ -z \"$pat\" ]; then echo 'missing pattern'; exit 2; fi; (command -v rg >/dev/null 2>&1 && rg -n \"$pat\" /work | head -n 500) || (grep -RIn --exclude-dir=.git \"$pat\" /work | head -n 500)"
    },
    {
      "id": "grep.files",
      "desc": "List files under /work matching pattern (rg -l). args: <pattern>",
      "cmd": "pat=\"{args}\"; if [ -z \"$pat\" ]; then echo 'missing pattern'; exit 2; fi; (command -v rg >/dev/null 2>&1 && rg -l \"$pat\" /work | head -n 900) || (grep -RIl --exclude-dir=.git \"$pat\" /work | head -n 900)"
    },

    {
      "id": "git.status",
      "desc": "Git status. args: <path optional>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then p=/work; fi; cd \"$p\" 2>/dev/null || exit 2; git status -sb"
    },
    {
      "id": "git.diff",
      "desc": "Git diff (trimmed). args: <path optional>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then p=/work; fi; cd \"$p\" 2>/dev/null || exit 2; git diff --stat && echo \"-----\" && git diff | head -n 1200"
    },
    {
      "id": "git.log",
      "desc": "Recent commits. args: <path optional>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then p=/work; fi; cd \"$p\" 2>/dev/null || exit 2; git --no-pager log --oneline -n 80"
    },
    {
      "id": "git.clone",
      "desc": "Clone a repo into /work. args: <url> <dest>",
      "cmd": "set -- {args}; url=\"$1\"; dest=\"$2\"; if [ -z \"$url\" ] || [ -z \"$dest\" ]; then echo 'usage: <url> <dest>'; exit 2; fi; cd /work && git clone \"$url\" \"$dest\""
    },

    {
      "id": "apt.update",
      "desc": "Update apt indexes.",
      "cmd": "bash -lc \"apt-get update\""
    },
    {
      "id": "apt.install",
      "desc": "Install Debian packages. args: <pkgs>",
      "cmd": "bash -lc \"pkgs=\\\"{args}\\\"; if [ -z \\\"$pkgs\\\" ]; then echo 'missing packages'; exit 2; fi; DEBIAN_FRONTEND=noninteractive apt-get install -y {args}\""
    },
    {
      "id": "apt.install.core",
      "desc": "Install core build tools (C/C++/git/curl/zip).",
      "cmd": "apt-get update && apt-get install -y build-essential clang lld cmake ninja-build pkg-config git curl wget unzip zip ca-certificates"
    },
    {
      "id": "apt.install.dotnet",
      "desc": "Install dotnet SDK prereqs (container-side, not Windows).",
      "cmd": "apt-get update && apt-get install -y libc6 libgcc-s1 libstdc++6 zlib1g libicu-dev"
    },
    {
      "id": "apt.install.languages",
      "desc": "Install a wide language toolchain (go/rust/node/python/java/php/ruby).",
      "cmd": "apt-get update && apt-get install -y gcc g++ clang make cmake ninja-build git curl wget python3 python3-venv python3-pip nodejs npm openjdk-17-jdk maven gradle golang-go rustc cargo php-cli phpunit ruby-full"
    },

    {
      "id": "dotnet.info",
      "desc": "Dotnet SDK/runtime info.",
      "cmd": "bash -lc \"dotnet --info\""
    },
    {
      "id": "dotnet.install.sdk",
      "desc": "Install dotnet SDK (8.0) on Debian/Ubuntu via Microsoft packages.",
      "cmd": "bash -lc \"set -euo pipefail; apt-get update; apt-get install -y wget apt-transport-https ca-certificates gnupg; rm -f /etc/apt/sources.list.d/microsoft-prod.list; wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O /tmp/packages-microsoft-prod.deb; dpkg -i /tmp/packages-microsoft-prod.deb; apt-get update; DEBIAN_FRONTEND=noninteractive apt-get install -y dotnet-sdk-8.0\""
    },
    {
      "id": "dotnet.build",
      "desc": "Dotnet build using dotnet CLI. args: <path optional> [extraArgs]",
      "cmd": "bash -lc \"dotnet build {args}\""
    },
    {
      "id": "dotnet.test",
      "desc": "Dotnet test using dotnet CLI. args: <path optional> [extraArgs]",
      "cmd": "bash -lc \"dotnet test {args}\""
    },
    {
      "id": "dotnet.new",
      "desc": "Create a dotnet project template. args: <template> <outputDir> [extraArgs]. Example: winforms MiniPad -f net8.0-windows",
      "cmd": "set -- {args}; tpl=\"$1\"; out=\"$2\"; shift 2 || true; if [ -z \"$tpl\" ] || [ -z \"$out\" ]; then echo 'usage: <template> <outputDir> [extraArgs]'; exit 2; fi; cd /work && dotnet new \"$tpl\" -o \"$out\" \"$@\""
    },
    {
      "id": "build.dotnet",
      "desc": "Dotnet build using dotnet CLI. args: <path optional> [extraArgs]",
      "cmd": "a=\"{args}\"; cd /work || exit 2; if [ -z \"$a\" ]; then dotnet build -v minimal; else dotnet build $a; fi"
    },
    {
      "id": "test.dotnet",
      "desc": "Dotnet test using dotnet CLI. args: <path optional> [extraArgs]",
      "cmd": "a=\"{args}\"; cd /work || exit 2; if [ -z \"$a\" ]; then dotnet test; else dotnet test $a; fi"
    },

    {
      "id": "fs.mkdir",
      "desc": "Create a directory under /work. args: <relative-path>",
      "cmd": "set -e; p=\"{args}\"; if [ -z \"$p\" ]; then echo 'missing path'; exit 2; fi; mkdir -p \"/work/$p\" && echo \"created /work/$p\""
    },

    {
      "id": "run.cmd",
      "desc": "Run a bash command safely (logged). args: <command>",
      "cmd": "set -e; if [ -z \"{args}\" ]; then echo 'missing command'; exit 2; fi; echo \"[run.cmd] {args}\"; bash -euo pipefail -c \"{args}\""
    },

    {
      "id": "docker.logs",
      "desc": "Container logs tail. args: <container> [n]",
      "cmd": "set -- {args}; c=\"$1\"; n=\"$2\"; if [ -z \"$c\" ]; then echo 'usage: <container> [n]'; exit 2; fi; if [ -z \"$n\" ]; then n=300; fi; docker logs --tail \"$n\" \"$c\" 2>/dev/null || echo 'docker not available inside container'"
    },

    {
      "id": "lang.detect",
      "desc": "Rough language detection by file extension under /work. args: <path optional>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then p=/work; fi; echo '[lang.detect] scanning:' \"$p\"; find \"$p\" -type f \\( -name '*.cs' -o -name '*.cpp' -o -name '*.c' -o -name '*.h' -o -name '*.hpp' -o -name '*.rs' -o -name '*.go' -o -name '*.py' -o -name '*.js' -o -name '*.ts' -o -name '*.java' -o -name '*.kt' -o -name '*.php' -o -name '*.rb' -o -name '*.swift' -o -name '*.lua' -o -name '*.sh' -o -name '*.ps1' \\) | sed 's/^.*\\.//' | sort | uniq -c | sort -nr | head -n 40"
    },

    {
      "id": "c.build",
      "desc": "Build a C file with gcc. args: <src.c> <out> [cflags...]",
      "cmd": "set -- {args}; src=\"$1\"; out=\"$2\"; shift 2 || true; if [ -z \"$src\" ] || [ -z \"$out\" ]; then echo 'usage: <src.c> <out> [cflags...]'; exit 2; fi; gcc \"$src\" -o \"$out\" \"$@\""
    },
    {
      "id": "cpp.build",
      "desc": "Build a C++ file with g++. args: <src.cpp> <out> [cxxflags...]",
      "cmd": "set -- {args}; src=\"$1\"; out=\"$2\"; shift 2 || true; if [ -z \"$src\" ] || [ -z \"$out\" ]; then echo 'usage: <src.cpp> <out> [cxxflags...]'; exit 2; fi; g++ \"$src\" -o \"$out\" \"$@\""
    },
    {
      "id": "cmake.configure",
      "desc": "CMake configure. args: <srcDir> <buildDir> [extraArgs...]",
      "cmd": "set -- {args}; src=\"$1\"; b=\"$2\"; shift 2 || true; if [ -z \"$src\" ] || [ -z \"$b\" ]; then echo 'usage: <srcDir> <buildDir> [extraArgs...]'; exit 2; fi; cmake -S \"$src\" -B \"$b\" -G Ninja \"$@\""
    },
    {
      "id": "cmake.build",
      "desc": "CMake build. args: <buildDir> [target]",
      "cmd": "set -- {args}; b=\"$1\"; t=\"$2\"; if [ -z \"$b\" ]; then echo 'usage: <buildDir> [target]'; exit 2; fi; if [ -z \"$t\" ]; then cmake --build \"$b\"; else cmake --build \"$b\" --target \"$t\"; fi"
    },

    {
      "id": "rust.build",
      "desc": "Cargo build. args: <projectDir> [--release]",
      "cmd": "set -- {args}; p=\"$1\"; mode=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [--release]'; exit 2; fi; cd \"$p\" && cargo build ${mode:-}"
    },
    {
      "id": "rust.test",
      "desc": "Cargo test. args: <projectDir>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir>'; exit 2; fi; cd \"$p\" && cargo test"
    },

    {
      "id": "go.build",
      "desc": "Go build. args: <projectDir> [outName]",
      "cmd": "set -- {args}; p=\"$1\"; out=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [outName]'; exit 2; fi; cd \"$p\" && if [ -z \"$out\" ]; then go build ./...; else go build -o \"$out\" ./...; fi"
    },
    {
      "id": "go.test",
      "desc": "Go test. args: <projectDir>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir>'; exit 2; fi; cd \"$p\" && go test ./..."
    },

    {
      "id": "node.install",
      "desc": "Node install deps. args: <projectDir>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir>'; exit 2; fi; cd \"$p\" && ( [ -f package-lock.json ] && npm ci || npm install )"
    },
    {
      "id": "node.build",
      "desc": "Node build script. args: <projectDir> [scriptName]",
      "cmd": "set -- {args}; p=\"$1\"; s=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [scriptName]'; exit 2; fi; if [ -z \"$s\" ]; then s=build; fi; cd \"$p\" && npm run \"$s\""
    },
    {
      "id": "node.test",
      "desc": "Node test script. args: <projectDir> [scriptName]",
      "cmd": "set -- {args}; p=\"$1\"; s=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [scriptName]'; exit 2; fi; if [ -z \"$s\" ]; then s=test; fi; cd \"$p\" && npm run \"$s\""
    },

    {
      "id": "python.venv",
      "desc": "Create venv. args: <projectDir> [venvName]",
      "cmd": "set -- {args}; p=\"$1\"; v=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [venvName]'; exit 2; fi; if [ -z \"$v\" ]; then v=.venv; fi; python3 -m venv \"$p/$v\" && echo \"created $p/$v\""
    },
    {
      "id": "python.pip.install",
      "desc": "Pip install requirements. args: <projectDir> [requirementsFile]",
      "cmd": "set -- {args}; p=\"$1\"; r=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [requirementsFile]'; exit 2; fi; if [ -z \"$r\" ]; then r=requirements.txt; fi; cd \"$p\" && python3 -m pip install -r \"$r\""
    },
    {
      "id": "python.run",
      "desc": "Run python module/script. args: <projectDir> <scriptOrModule> [args...]",
      "cmd": "set -- {args}; p=\"$1\"; s=\"$2\"; shift 2 || true; if [ -z \"$p\" ] || [ -z \"$s\" ]; then echo 'usage: <projectDir> <scriptOrModule> [args...]'; exit 2; fi; cd \"$p\" && python3 \"$s\" \"$@\""
    },
    {
      "id": "file.read.text",
      "desc": "Read a small text file (txt|md|json|csv) and emit JSON {filename,sha256,content}. args: <path>",
      "cmd": "bash -lc \"p=\\\"{args}\\\"; if [ -z \\\"$p\\\" ]; then echo '{\"error\":\"missing_path\"}'; exit 1; fi; ext=${p##*.}; case \\\"${ext,,}\\\" in txt|md|json|csv) ;; *) echo '{\"error\":\"unsupported_extension\"}'; exit 1;; esac; if [ ! -f \\\"$p\\\" ]; then echo '{\"error\":\"not_found\"}'; exit 1; fi; max=52428800; size=$(stat -c%s \\\"$p\\\" 2>/dev/null || echo 0); if [ \"$size\" -gt \"$max\" ]; then echo '{\"error\":\"too_large\"}'; exit 1; fi; PATH_TO_READ=\\\"$p\\\" python3 - <<'PY'\nimport json, hashlib, os\np=os.environ['PATH_TO_READ']\nwith open(p,'rb') as f:\n    data=f.read()\nsha=hashlib.sha256(data).hexdigest()\ntext=data.decode('utf-8','replace')\nprint(json.dumps({\"filename\":os.path.basename(p),\"sha256\":sha,\"content\":text}))\nPY\n\""
    },
    {
      "id": "vision.describe.image",
      "desc": "Describe an image using a vision-capable model (requires Vision role). args: <imagePath>",
      "cmd": "echo 'vision.describe.image requires configured Vision role/model; execution is gated by prompts.'"
    },

    {
      "id": "java.maven.build",
      "desc": "Maven build. args: <projectDir> [goals...] (default: package)",
      "cmd": "set -- {args}; p=\"$1\"; shift 1 || true; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [goals...]'; exit 2; fi; cd \"$p\" && if [ $# -eq 0 ]; then mvn -q -DskipTests package; else mvn \"$@\"; fi"
    },
    {
      "id": "java.gradle.build",
      "desc": "Gradle build. args: <projectDir> [task] (default: build)",
      "cmd": "set -- {args}; p=\"$1\"; t=\"$2\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir> [task]'; exit 2; fi; if [ -z \"$t\" ]; then t=build; fi; cd \"$p\" && ( [ -f gradlew ] && ./gradlew \"$t\" || gradle \"$t\" )"
    },

    {
      "id": "php.composer.install",
      "desc": "Composer install. args: <projectDir>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir>'; exit 2; fi; cd \"$p\" && composer install"
    },
    {
      "id": "ruby.bundle.install",
      "desc": "Bundler install. args: <projectDir>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <projectDir>'; exit 2; fi; cd \"$p\" && bundle install"
    },

    {
      "id": "fmt.format",
      "desc": "Formatting pass (C/C++ clang-format if present). args: <path>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <path>'; exit 2; fi; if command -v clang-format >/dev/null 2>&1; then find \"$p\" -type f \\( -name '*.c' -o -name '*.h' -o -name '*.cpp' -o -name '*.hpp' \\) -print0 | xargs -0 -n 25 clang-format -i; echo '[fmt.format] clang-format done'; else echo 'clang-format not installed'; exit 2; fi"
    },
    {
      "id": "lint.cpp",
      "desc": "Static analysis (cppcheck) if installed. args: <path>",
      "cmd": "p=\"{args}\"; if [ -z \"$p\" ]; then echo 'usage: <path>'; exit 2; fi; if command -v cppcheck >/dev/null 2>&1; then cppcheck --enable=warning,style,performance --inline-suppr \"$p\" || true; else echo 'cppcheck not installed'; exit 2; fi"
    },

    {
      "id": "dbg.gdb",
      "desc": "Run gdb on a binary. args: <binary> [args...]",
      "cmd": "set -- {args}; bin=\"$1\"; shift 1 || true; if [ -z \"$bin\" ]; then echo 'usage: <binary> [args...]'; exit 2; fi; gdb --args \"$bin\" \"$@\""
    },
    {
      "id": "dbg.valgrind",
      "desc": "Run valgrind on a binary. args: <binary> [args...]",
      "cmd": "set -- {args}; bin=\"$1\"; shift 1 || true; if [ -z \"$bin\" ]; then echo 'usage: <binary> [args...]'; exit 2; fi; valgrind --leak-check=full \"$bin\" \"$@\""
    }
  ]
}
